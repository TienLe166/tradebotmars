# Advanced Crypto Trading Bot
# Ph√°t tri·ªÉn b·ªüi: Expert Crypto Trader & Python Developer
# M·ª•c ti√™u: Bot giao d·ªãch crypto th√¥ng minh v·ªõi AI, qu·∫£n l√Ω r·ªßi ro n√¢ng cao

import asyncio
import ccxt
import pandas as pd
import numpy as np
import sqlite3
import tweepy
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import json
import hashlib
from dataclasses import dataclass
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import ta
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# =============================================================================
# CONFIGURATION & CONSTANTS
# =============================================================================

@dataclass
class BotConfig:
    """C·∫•u h√¨nh ch√≠nh c·ªßa bot"""
    # API Keys (C·∫ßn ƒë∆∞·ª£c c·∫•u h√¨nh)
    TELEGRAM_BOT_TOKEN: str = "YOUR_TELEGRAM_BOT_TOKEN"
    BINANCE_API_KEY: str = "YOUR_BINANCE_API_KEY"
    BINANCE_SECRET_KEY: str = "YOUR_BINANCE_SECRET_KEY"
    TWITTER_BEARER_TOKEN: str = "YOUR_TWITTER_BEARER_TOKEN"
    
    # Trading Parameters
    DEFAULT_RISK_PERCENT: float = 2.0  # % v·ªën r·ªßi ro m·ªói l·ªánh
    DEFAULT_PAIRS: List[str] = None
    TIMEFRAMES: List[str] = None
    MIN_VOLUME_USDT: float = 1000000  # Volume t·ªëi thi·ªÉu
    
    # ML Parameters
    ML_LOOKBACK_DAYS: int = 30
    ML_RETRAIN_HOURS: int = 24
    
    # Portfolio Optimization
    PORTFOLIO_REBALANCE_HOURS: int = 8
    
    def __post_init__(self):
        if self.DEFAULT_PAIRS is None:
            self.DEFAULT_PAIRS = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'ADA/USDT']
        if self.TIMEFRAMES is None:
            self.TIMEFRAMES = ['5m', '15m', '1h', '4h', '1d']

config = BotConfig()

# =============================================================================
# LOGGING SETUP
# =============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('crypto_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# =============================================================================
# DATABASE MANAGER
# =============================================================================

class DatabaseManager:
    """Qu·∫£n l√Ω c∆° s·ªü d·ªØ li·ªáu SQLite"""
    
    def __init__(self, db_path: str = "crypto_bot.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Kh·ªüi t·∫°o c∆° s·ªü d·ªØ li·ªáu"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # B·∫£ng l∆∞u d·ªØ li·ªáu gi√°
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS price_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                timeframe TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                open REAL NOT NULL,
                high REAL NOT NULL,
                low REAL NOT NULL,
                close REAL NOT NULL,
                volume REAL NOT NULL,
                UNIQUE(symbol, timeframe, timestamp)
            )
        ''')
        
        # B·∫£ng l∆∞u t√≠n hi·ªáu giao d·ªãch
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                signal_type TEXT NOT NULL,
                entry_price REAL NOT NULL,
                stop_loss REAL,
                take_profit REAL,
                confidence REAL NOT NULL,
                sentiment_score REAL,
                ml_score REAL,
                timestamp INTEGER NOT NULL,
                status TEXT DEFAULT 'active'
            )
        ''')
        
        # B·∫£ng l∆∞u d·ªØ li·ªáu sentiment
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sentiment_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                source TEXT NOT NULL,
                sentiment_score REAL NOT NULL,
                text_content TEXT,
                timestamp INTEGER NOT NULL
            )
        ''')
        
        # B·∫£ng l∆∞u hi·ªáu su·∫•t
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS performance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                entry_price REAL NOT NULL,
                exit_price REAL NOT NULL,
                pnl_percent REAL NOT NULL,
                pnl_usdt REAL NOT NULL,
                entry_time INTEGER NOT NULL,
                exit_time INTEGER NOT NULL,
                signal_id INTEGER
            )
        ''')
        
        conn.commit()
        conn.close()
        logger.info("Database initialized successfully")
    
    def insert_price_data(self, symbol: str, timeframe: str, ohlcv_data: List):
        """Ch√®n d·ªØ li·ªáu gi√° v√†o database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for data in ohlcv_data:
            try:
                cursor.execute('''
                    INSERT OR REPLACE INTO price_data 
                    (symbol, timeframe, timestamp, open, high, low, close, volume)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (symbol, timeframe, data[0], data[1], data[2], data[3], data[4], data[5]))
            except Exception as e:
                logger.error(f"Error inserting price data: {e}")
        
        conn.commit()
        conn.close()
    
    def get_price_data(self, symbol: str, timeframe: str, limit: int = 100) -> pd.DataFrame:
        """L·∫•y d·ªØ li·ªáu gi√° t·ª´ database"""
        conn = sqlite3.connect(self.db_path)
        
        query = '''
            SELECT timestamp, open, high, low, close, volume
            FROM price_data
            WHERE symbol = ? AND timeframe = ?
            ORDER BY timestamp DESC
            LIMIT ?
        '''
        
        df = pd.read_sql_query(query, conn, params=(symbol, timeframe, limit))
        conn.close()
        
        if not df.empty:
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)
            df = df.sort_index()
        
        return df

# =============================================================================
# DATA COLLECTOR
# =============================================================================

class DataCollector:
    """Thu th·∫≠p d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.exchanges = {}
        self.twitter_client = None
        self.init_exchanges()
        self.init_twitter()
    
    def init_exchanges(self):
        """Kh·ªüi t·∫°o k·∫øt n·ªëi v·ªõi c√°c s√†n giao d·ªãch"""
        try:
            # Binance
            self.exchanges['binance'] = ccxt.binance({
                'apiKey': config.BINANCE_API_KEY,
                'secret': config.BINANCE_SECRET_KEY,
                'sandbox': False,  # Set True for testnet
                'enableRateLimit': True,
            })
            
            # Coinbase Pro
            self.exchanges['coinbase'] = ccxt.coinbasepro({
                'enableRateLimit': True,
            })
            
            # Kraken
            self.exchanges['kraken'] = ccxt.kraken({
                'enableRateLimit': True,
            })
            
            logger.info("Exchanges initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing exchanges: {e}")
    
    def init_twitter(self):
        """Kh·ªüi t·∫°o Twitter API cho sentiment analysis"""
        try:
            if config.TWITTER_BEARER_TOKEN:
                self.twitter_client = tweepy.Client(
                    bearer_token=config.TWITTER_BEARER_TOKEN,
                    wait_on_rate_limit=True
                )
                logger.info("Twitter API initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing Twitter API: {e}")
    
    async def collect_price_data(self, symbol: str, timeframe: str = '1h', limit: int = 100):
        """Thu th·∫≠p d·ªØ li·ªáu gi√° t·ª´ s√†n giao d·ªãch"""
        try:
            exchange = self.exchanges['binance']
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            
            # L∆∞u v√†o database
            self.db_manager.insert_price_data(symbol, timeframe, ohlcv)
            
            return ohlcv
            
        except Exception as e:
            logger.error(f"Error collecting price data for {symbol}: {e}")
            return []
    
    async def collect_sentiment_data(self, symbol: str) -> float:
        """Thu th·∫≠p v√† ph√¢n t√≠ch sentiment t·ª´ Twitter"""
        try:
            if not self.twitter_client:
                return 0.0
            
            # L·∫•y symbol ch√≠nh (BTC t·ª´ BTC/USDT)
            base_symbol = symbol.split('/')[0]
            
            # T√¨m ki·∫øm tweets
            query = f"{base_symbol} crypto OR {base_symbol} price OR #{base_symbol} -is:retweet lang:en"
            tweets = self.twitter_client.search_recent_tweets(
                query=query,
                max_results=50,
                tweet_fields=['created_at', 'public_metrics']
            )
            
            if not tweets.data:
                return 0.0
            
            # Ph√¢n t√≠ch sentiment ƒë∆°n gi·∫£n
            sentiment_scores = []
            positive_words = ['bull', 'bullish', 'moon', 'pump', 'buy', 'long', 'hodl', 'up', 'rise', 'gain']
            negative_words = ['bear', 'bearish', 'dump', 'sell', 'short', 'crash', 'down', 'fall', 'loss']
            
            for tweet in tweets.data:
                text = tweet.text.lower()
                positive_count = sum(1 for word in positive_words if word in text)
                negative_count = sum(1 for word in negative_words if word in text)
                
                if positive_count > 0 or negative_count > 0:
                    score = (positive_count - negative_count) / (positive_count + negative_count + 1)
                    # Tr·ªçng s·ªë theo engagement
                    weight = (tweet.public_metrics['like_count'] + 
                             tweet.public_metrics['retweet_count'] + 1)
                    sentiment_scores.append(score * np.log(weight))
            
            if sentiment_scores:
                avg_sentiment = np.mean(sentiment_scores)
                # Chu·∫©n h√≥a v·ªÅ [-1, 1]
                return np.tanh(avg_sentiment)
            
            return 0.0
            
        except Exception as e:
            logger.error(f"Error collecting sentiment data: {e}")
            return 0.0
    
    def get_best_exchange_price(self, symbol: str, side: str = 'buy') -> Tuple[str, float]:
        """T√¨m s√†n c√≥ gi√° t·ªët nh·∫•t"""
        best_exchange = None
        best_price = None
        
        for exchange_name, exchange in self.exchanges.items():
            try:
                ticker = exchange.fetch_ticker(symbol)
                price = ticker['bid'] if side == 'sell' else ticker['ask']
                
                if best_price is None or (
                    (side == 'buy' and price < best_price) or
                    (side == 'sell' and price > best_price)
                ):
                    best_price = price
                    best_exchange = exchange_name
                    
            except Exception as e:
                logger.warning(f"Error fetching price from {exchange_name}: {e}")
        
        return best_exchange, best_price

# =============================================================================
# TECHNICAL ANALYSIS ENGINE
# =============================================================================

class TechnicalAnalyzer:
    """Ph√¢n t√≠ch k·ªπ thu·∫≠t n√¢ng cao"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """T√≠nh to√°n c√°c ch·ªâ b√°o k·ªπ thu·∫≠t"""
        try:
            # Moving Averages
            df['MA_20'] = df['close'].rolling(window=20).mean()
            df['MA_50'] = df['close'].rolling(window=50).mean()
            df['MA_100'] = df['close'].rolling(window=100).mean()
            df['MA_200'] = df['close'].rolling(window=200).mean()
            
            # Exponential Moving Averages
            df['EMA_12'] = df['close'].ewm(span=12).mean()
            df['EMA_26'] = df['close'].ewm(span=26).mean()
            
            # MACD
            df['MACD'] = df['EMA_12'] - df['EMA_26']
            df['MACD_signal'] = df['MACD'].ewm(span=9).mean()
            df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
            
            # RSI
            df['RSI'] = ta.momentum.RSIIndicator(df['close'], window=14).rsi()
            
            # Bollinger Bands
            bb_indicator = ta.volatility.BollingerBands(df['close'], window=20, window_dev=2)
            df['BB_upper'] = bb_indicator.bollinger_hband()
            df['BB_middle'] = bb_indicator.bollinger_mavg()
            df['BB_lower'] = bb_indicator.bollinger_lband()
            df['BB_width'] = (df['BB_upper'] - df['BB_lower']) / df['BB_middle']
            
            # ATR (Average True Range)
            df['ATR'] = ta.volatility.AverageTrueRange(
                df['high'], df['low'], df['close'], window=14
            ).average_true_range()
            
            # Volume indicators
            df['Volume_MA'] = df['volume'].rolling(window=20).mean()
            df['Volume_ratio'] = df['volume'] / df['Volume_MA']
            
            # Stochastic
            stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'])
            df['Stoch_K'] = stoch.stoch()
            df['Stoch_D'] = stoch.stoch_signal()
            
            # Williams %R
            df['Williams_R'] = ta.momentum.WilliamsRIndicator(
                df['high'], df['low'], df['close'], lbp=14
            ).williams_r()
            
            # Commodity Channel Index
            df['CCI'] = ta.trend.CCIIndicator(
                df['high'], df['low'], df['close'], window=20
            ).cci()
            
            # Support and Resistance levels
            df = self.calculate_support_resistance(df)
            
            return df
            
        except Exception as e:
            logger.error(f"Error calculating indicators: {e}")
            return df
    
    def calculate_support_resistance(self, df: pd.DataFrame, window: int = 20) -> pd.DataFrame:
        """T√≠nh to√°n m·ª©c h·ªó tr·ª£ v√† kh√°ng c·ª±"""
        try:
            # T√¨m local highs v√† lows
            df['local_high'] = df['high'].rolling(window=window, center=True).max() == df['high']
            df['local_low'] = df['low'].rolling(window=window, center=True).min() == df['low']
            
            # T√≠nh to√°n m·ª©c h·ªó tr·ª£ v√† kh√°ng c·ª± g·∫ßn nh·∫•t
            resistance_levels = df[df['local_high']]['high'].tail(3).values
            support_levels = df[df['local_low']]['low'].tail(3).values
            
            if len(resistance_levels) > 0:
                df['resistance'] = np.max(resistance_levels)
            else:
                df['resistance'] = df['high'].max()
                
            if len(support_levels) > 0:
                df['support'] = np.min(support_levels)
            else:
                df['support'] = df['low'].min()
            
            return df
            
        except Exception as e:
            logger.error(f"Error calculating support/resistance: {e}")
            return df
    
    def detect_patterns(self, df: pd.DataFrame) -> Dict:
        """Ph√°t hi·ªán c√°c m·∫´u gi√° c·ªï ƒëi·ªÉn"""
        patterns = {
            'golden_cross': False,
            'death_cross': False,
            'bullish_divergence': False,
            'bearish_divergence': False,
            'hammer': False,
            'doji': False,
            'engulfing_bull': False,
            'engulfing_bear': False
        }
        
        try:
            if len(df) < 50:
                return patterns
            
            # Golden Cross v√† Death Cross
            if df['MA_50'].iloc[-2] <= df['MA_200'].iloc[-2] and df['MA_50'].iloc[-1] > df['MA_200'].iloc[-1]:
                patterns['golden_cross'] = True
            elif df['MA_50'].iloc[-2] >= df['MA_200'].iloc[-2] and df['MA_50'].iloc[-1] < df['MA_200'].iloc[-1]:
                patterns['death_cross'] = True
            
            # MACD Divergence
            price_trend = (df['close'].iloc[-1] - df['close'].iloc[-10]) / df['close'].iloc[-10]
            macd_trend = (df['MACD'].iloc[-1] - df['MACD'].iloc[-10]) / abs(df['MACD'].iloc[-10] + 0.0001)
            
            if price_trend < 0 and macd_trend > 0:  # Gi√° gi·∫£m nh∆∞ng MACD tƒÉng
                patterns['bullish_divergence'] = True
            elif price_trend > 0 and macd_trend < 0:  # Gi√° tƒÉng nh∆∞ng MACD gi·∫£m
                patterns['bearish_divergence'] = True
            
            # Candlestick patterns
            current = df.iloc[-1]
            previous = df.iloc[-2]
            
            # Hammer pattern
            body_size = abs(current['close'] - current['open'])
            upper_shadow = current['high'] - max(current['close'], current['open'])
            lower_shadow = min(current['close'], current['open']) - current['low']
            
            if lower_shadow > 2 * body_size and upper_shadow < body_size:
                patterns['hammer'] = True
            
            # Doji pattern
            if body_size < (current['high'] - current['low']) * 0.1:
                patterns['doji'] = True
            
            # Engulfing patterns
            if (previous['close'] < previous['open'] and  # Previous bearish
                current['close'] > current['open'] and   # Current bullish
                current['open'] < previous['close'] and  # Opens below previous close
                current['close'] > previous['open']):    # Closes above previous open
                patterns['engulfing_bull'] = True
            
            elif (previous['close'] > previous['open'] and  # Previous bullish
                  current['close'] < current['open'] and   # Current bearish
                  current['open'] > previous['close'] and  # Opens above previous close
                  current['close'] < previous['open']):    # Closes below previous open
                patterns['engulfing_bear'] = True
            
        except Exception as e:
            logger.error(f"Error detecting patterns: {e}")
        
        return patterns

# =============================================================================
# MACHINE LEARNING ENGINE
# =============================================================================

class MLEngine:
    """Machine Learning cho d·ª± ƒëo√°n xu h∆∞·ªõng"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.models = {}
        self.scalers = {}
    
    def prepare_features(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """Chu·∫©n b·ªã features cho ML model"""
        try:
            # Features selection
            feature_columns = [
                'RSI', 'MACD', 'MACD_signal', 'BB_width', 'ATR',
                'Volume_ratio', 'Stoch_K', 'Stoch_D', 'Williams_R', 'CCI'
            ]
            
            # Th√™m c√°c features t·ª´ price action
            df['price_change_5'] = df['close'].pct_change(5)
            df['price_change_10'] = df['close'].pct_change(10)
            df['high_low_ratio'] = (df['high'] - df['low']) / df['close']
            df['close_position'] = (df['close'] - df['low']) / (df['high'] - df['low'])
            
            feature_columns.extend(['price_change_5', 'price_change_10', 'high_low_ratio', 'close_position'])
            
            # Target: Price movement trong 5 periods ti·∫øp theo
            df['future_return'] = df['close'].shift(-5).pct_change()
            df['target'] = (df['future_return'] > 0.02).astype(int)  # 2% threshold
            
            # Remove NaN values
            df_clean = df.dropna()
            
            if len(df_clean) < 50:
                return None, None
            
            X = df_clean[feature_columns].values
            y = df_clean['target'].values
            
            return X, y
            
        except Exception as e:
            logger.error(f"Error preparing features: {e}")
            return None, None
    
    def train_model(self, symbol: str, df: pd.DataFrame) -> float:
        """Hu·∫•n luy·ªán ML model cho symbol c·ª• th·ªÉ"""
        try:
            X, y = self.prepare_features(df)
            
            if X is None or len(X) < 100:
                logger.warning(f"Insufficient data for training {symbol}")
                return 0.0
            
            # Split data
            split_idx = int(len(X) * 0.8)
            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]
            
            # Scale features
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            # Train Random Forest
            model = RandomForestClassifier(
                n_estimators=100,
                max_depth=10,
                min_samples_split=5,
                min_samples_leaf=2,
                random_state=42
            )
            
            model.fit(X_train_scaled, y_train)
            
            # Evaluate
            accuracy = model.score(X_test_scaled, y_test)
            
            # Save model and scaler
            self.models[symbol] = model
            self.scalers[symbol] = scaler
            
            logger.info(f"ML model trained for {symbol} with accuracy: {accuracy:.3f}")
            return accuracy
            
        except Exception as e:
            logger.error(f"Error training ML model for {symbol}: {e}")
            return 0.0
    
    def predict_signal(self, symbol: str, df: pd.DataFrame) -> Tuple[float, float]:
        """D·ª± ƒëo√°n t√≠n hi·ªáu giao d·ªãch"""
        try:
            if symbol not in self.models:
                logger.warning(f"No ML model found for {symbol}")
                return 0.0, 0.0
            
            X, _ = self.prepare_features(df)
            
            if X is None or len(X) == 0:
                return 0.0, 0.0
            
            # Get latest features
            latest_features = X[-1].reshape(1, -1)
            
            # Scale features
            scaler = self.scalers[symbol]
            latest_features_scaled = scaler.transform(latest_features)
            
            # Predict
            model = self.models[symbol]
            probability = model.predict_proba(latest_features_scaled)[0]
            
            # Return probability of bullish signal and confidence
            bullish_prob = probability[1] if len(probability) > 1 else 0.0
            confidence = max(probability) - min(probability) if len(probability) > 1 else 0.0
            
            return bullish_prob, confidence
            
        except Exception as e:
            logger.error(f"Error predicting with ML model: {e}")
            return 0.0, 0.0

# =============================================================================
# SIGNAL GENERATOR
# =============================================================================

@dataclass
class TradingSignal:
    """C·∫•u tr√∫c t√≠n hi·ªáu giao d·ªãch"""
    symbol: str
    signal_type: str  # 'BUY' ho·∫∑c 'SELL'
    entry_price: float
    stop_loss: float
    take_profit: float
    confidence: float
    sentiment_score: float
    ml_score: float
    reason: str
    timestamp: datetime

class SignalGenerator:
    """T·∫°o ra t√≠n hi·ªáu giao d·ªãch d·ª±a tr√™n ph√¢n t√≠ch t·ªïng h·ª£p"""
    
    def __init__(self, db_manager: DatabaseManager, data_collector: DataCollector, 
                 tech_analyzer: TechnicalAnalyzer, ml_engine: MLEngine):
        self.db_manager = db_manager
        self.data_collector = data_collector
        self.tech_analyzer = tech_analyzer
        self.ml_engine = ml_engine
    
    async def generate_signal(self, symbol: str, timeframe: str = '1h') -> Optional[TradingSignal]:
        """T·∫°o t√≠n hi·ªáu giao d·ªãch cho m·ªôt symbol"""
        try:
            # L·∫•y d·ªØ li·ªáu gi√°
            await self.data_collector.collect_price_data(symbol, timeframe, limit=200)
            df = self.db_manager.get_price_data(symbol, timeframe, limit=200)
            
            if df.empty or len(df) < 100:
                logger.warning(f"Insufficient price data for {symbol}")
                return None
            
            # T√≠nh to√°n ch·ªâ b√°o k·ªπ thu·∫≠t
            df = self.tech_analyzer.calculate_indicators(df)
            
            # Ph√°t hi·ªán patterns
            patterns = self.tech_analyzer.detect_patterns(df)
            
            # Thu th·∫≠p sentiment
            sentiment_score = await self.data_collector.collect_sentiment_data(symbol)
            
            # ML prediction
            ml_score, ml_confidence = self.ml_engine.predict_signal(symbol, df)
            
            # T√≠nh to√°n t√≠n hi·ªáu t·ªïng h·ª£p
            signal = self.calculate_composite_signal(df, patterns, sentiment_score, ml_score, ml_confidence)
            
            if signal:
                signal.symbol = symbol
                signal.sentiment_score = sentiment_score
                signal.ml_score = ml_score
                
                # L∆∞u v√†o database
                await self.save_signal(signal)
                
                logger.info(f"Generated signal for {symbol}: {signal.signal_type} at {signal.entry_price}")
                
            return signal
            
        except Exception as e:
            logger.error(f"Error generating signal for {symbol}: {e}")
            return None
    
    def calculate_composite_signal(self, df: pd.DataFrame, patterns: Dict, 
                                 sentiment_score: float, ml_score: float, 
                                 ml_confidence: float) -> Optional[TradingSignal]:
        """T√≠nh to√°n t√≠n hi·ªáu t·ªïng h·ª£p t·ª´ nhi·ªÅu ngu·ªìn"""
        try:
            current = df.iloc[-1]
            prev = df.iloc[-2]
            
            # Technical Analysis Score
            tech_score = 0
            reasons = []
            
            # Moving Average signals
            if current['close'] > current['MA_20'] > current['MA_50']:
                tech_score += 0.2
                reasons.append("Price above MA20>MA50")
            elif current['close'] < current['MA_20'] < current['MA_50']:
                tech_score -= 0.2
                reasons.append("Price below MA20<MA50")
            
            # MACD signals
            if current['MACD'] > current['MACD_signal'] and prev['MACD'] <= prev['MACD_signal']:
                tech_score += 0.3
                reasons.append("MACD bullish crossover")
            elif current['MACD'] < current['MACD_signal'] and prev['MACD'] >= prev['MACD_signal']:
                tech_score -= 0.3
                reasons.append("MACD bearish crossover")
            
            # RSI signals
            if current['RSI'] < 30 and prev['RSI'] >= 30:
                tech_score += 0.2
                reasons.append("RSI oversold recovery")
            elif current['RSI'] > 70 and prev['RSI'] <= 70:
                tech_score -= 0.2
                reasons.append("RSI overbought")
            
            # Bollinger Bands signals
            if current['close'] <= current['BB_lower'] and prev['close'] > prev['BB_lower']:
                tech_score += 0.15
                reasons.append("Price touching lower BB")
            elif current['close'] >= current['BB_upper'] and prev['close'] < prev['BB_upper']:
                tech_score -= 0.15
                reasons.append("Price touching upper BB")
            
            # Pattern signals
            if patterns['golden_cross']:
                tech_score += 0.4
                reasons.append("Golden cross detected")
            elif patterns['death_cross']:
                tech_score -= 0.4
                reasons.append("Death cross detected")
            
            if patterns['bullish_divergence']:
                tech_score += 0.3
                reasons.append("Bullish divergence")
            elif patterns['bearish_divergence']:
                tech_score -= 0.3
                reasons.append("Bearish divergence")
            
            if patterns['hammer'] or patterns['engulfing_bull']:
                tech_score += 0.2
                reasons.append("Bullish candlestick pattern")
            elif patterns['engulfing_bear']:
                tech_score -= 0.2
                reasons.append("Bearish candlestick pattern")
            
            # Volume confirmation
            if current['Volume_ratio'] > 1.5:
                tech_score *= 1.2  # Boost signal with high volume
                reasons.append("High volume confirmation")
            
            # T√≠nh to√°n ƒëi·ªÉm t·ªïng h·ª£p
            # Tr·ªçng s·ªë: Technical 40%, Sentiment 25%, ML 35%
            composite_score = (tech_score * 0.4 + 
                             sentiment_score * 0.25 + 
                             (ml_score - 0.5) * 0.35)
            
            # Confidence calculation
            confidence = (abs(tech_score) * 0.4 + 
                         abs(sentiment_score) * 0.25 + 
                         ml_confidence * 0.35)
            
            # Threshold cho t√≠n hi·ªáu
            if composite_score > 0.3 and confidence > 0.4:
                signal_type = "BUY"
            elif composite_score < -0.3 and confidence > 0.4:
                signal_type = "SELL"
            else:
                return None
            
            # T√≠nh to√°n entry, stop loss, take profit
            entry_price = current['close']
            atr = current['ATR']
            
            if signal_type == "BUY":
                stop_loss = entry_price - (atr * 2)
                take_profit = entry_price + (atr * 3)
            else:
                stop_loss = entry_price + (atr * 2)
                take_profit = entry_price - (atr * 3)
            
            return TradingSignal(
                symbol="",  # Will be set by caller
                signal_type=signal_type,
                entry_price=entry_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                confidence=confidence,
                sentiment_score=sentiment_score,
                ml_score=ml_score,
                reason=" | ".join(reasons[:3]),  # Top 3 reasons
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Error calculating composite signal: {e}")
            return None
    
    async def save_signal(self, signal: TradingSignal):
        """L∆∞u t√≠n hi·ªáu v√†o database"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO signals 
                (symbol, signal_type, entry_price, stop_loss, take_profit, 
                 confidence, sentiment_score, ml_score, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                signal.symbol, signal.signal_type, signal.entry_price,
                signal.stop_loss, signal.take_profit, signal.confidence,
                signal.sentiment_score, signal.ml_score,
                int(signal.timestamp.timestamp() * 1000)
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error saving signal: {e}")

# =============================================================================
# RISK MANAGEMENT
# =============================================================================

class RiskManager:
    """Qu·∫£n l√Ω r·ªßi ro n√¢ng cao"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.max_risk_per_trade = config.DEFAULT_RISK_PERCENT / 100
        self.max_portfolio_risk = 0.1  # 10% t·ªïng v·ªën
        self.max_daily_loss = 0.05  # 5% v·ªën m·ªói ng√†y
    
    def calculate_position_size(self, signal: TradingSignal, account_balance: float) -> float:
        """T√≠nh to√°n k√≠ch th∆∞·ªõc v·ªã th·∫ø d·ª±a tr√™n r·ªßi ro"""
        try:
            # Risk per trade based on stop loss
            risk_per_share = abs(signal.entry_price - signal.stop_loss)
            risk_amount = account_balance * self.max_risk_per_trade
            
            # Position size calculation
            position_size = risk_amount / risk_per_share
            
            # Adjust based on confidence
            confidence_multiplier = min(signal.confidence * 1.5, 1.2)
            position_size *= confidence_multiplier
            
            # Maximum position size (no more than 20% of balance)
            max_position_value = account_balance * 0.2
            max_shares = max_position_value / signal.entry_price
            
            position_size = min(position_size, max_shares)
            
            logger.info(f"Calculated position size: {position_size:.6f} for {signal.symbol}")
            return max(position_size, 0)
            
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return 0
    
    def check_risk_limits(self, new_signal: TradingSignal, active_positions: List) -> bool:
        """Ki·ªÉm tra gi·ªõi h·∫°n r·ªßi ro tr∆∞·ªõc khi v√†o l·ªánh"""
        try:
            # Ki·ªÉm tra s·ªë l∆∞·ª£ng positions ƒëang m·ªü
            if len(active_positions) >= 5:  # Max 5 positions
                logger.warning("Maximum number of positions reached")
                return False
            
            # Ki·ªÉm tra correlation gi·ªØa c√°c symbols
            symbols = [pos['symbol'] for pos in active_positions]
            if new_signal.symbol in symbols:
                logger.warning(f"Already have position in {new_signal.symbol}")
                return False
            
            # Ki·ªÉm tra daily loss limit
            today_pnl = self.get_today_pnl()
            if today_pnl < -self.max_daily_loss:
                logger.warning("Daily loss limit reached")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error checking risk limits: {e}")
            return False
    
    def get_today_pnl(self) -> float:
        """L·∫•y P&L c·ªßa ng√†y h√¥m nay"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
            today_timestamp = int(today_start.timestamp() * 1000)
            
            cursor.execute('''
                SELECT SUM(pnl_percent) as total_pnl
                FROM performance
                WHERE exit_time >= ?
            ''', (today_timestamp,))
            
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result[0] else 0.0
            
        except Exception as e:
            logger.error(f"Error getting today PnL: {e}")
            return 0.0
    
    def update_trailing_stop(self, position: Dict, current_price: float) -> float:
        """C·∫≠p nh·∫≠t trailing stop loss"""
        try:
            entry_price = position['entry_price']
            current_stop = position['stop_loss']
            signal_type = position['signal_type']
            
            if signal_type == "BUY":
                # For long positions
                price_change = (current_price - entry_price) / entry_price
                
                if price_change > 0.02:  # 2% profit
                    # Move stop loss to break even
                    new_stop = max(current_stop, entry_price)
                    
                if price_change > 0.05:  # 5% profit
                    # Trail stop at 50% of profit
                    new_stop = entry_price + (current_price - entry_price) * 0.5
                    new_stop = max(current_stop, new_stop)
                else:
                    new_stop = current_stop
            
            else:  # SELL position
                price_change = (entry_price - current_price) / entry_price
                
                if price_change > 0.02:  # 2% profit
                    new_stop = min(current_stop, entry_price)
                    
                if price_change > 0.05:  # 5% profit
                    new_stop = entry_price - (entry_price - current_price) * 0.5
                    new_stop = min(current_stop, new_stop)
                else:
                    new_stop = current_stop
            
            return new_stop
            
        except Exception as e:
            logger.error(f"Error updating trailing stop: {e}")
            return position['stop_loss']

# =============================================================================
# PORTFOLIO OPTIMIZER
# =============================================================================

class PortfolioOptimizer:
    """T·ªëi ∆∞u h√≥a danh m·ª•c ƒë·∫ßu t∆∞ theo Modern Portfolio Theory"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def calculate_optimal_weights(self, symbols: List[str], lookback_days: int = 30) -> Dict[str, float]:
        """T√≠nh to√°n tr·ªçng s·ªë t·ªëi ∆∞u cho danh m·ª•c"""
        try:
            # L·∫•y d·ªØ li·ªáu returns
            returns_data = {}
            
            for symbol in symbols:
                df = self.db_manager.get_price_data(symbol, '1d', limit=lookback_days)
                if not df.empty:
                    returns = df['close'].pct_change().dropna()
                    returns_data[symbol] = returns
            
            if len(returns_data) < 2:
                # Equal weights if insufficient data
                equal_weight = 1.0 / len(symbols)
                return {symbol: equal_weight for symbol in symbols}
            
            # Create returns matrix
            returns_df = pd.DataFrame(returns_data)
            returns_df = returns_df.dropna()
            
            if len(returns_df) < 10:
                equal_weight = 1.0 / len(symbols)
                return {symbol: equal_weight for symbol in symbols}
            
            # Calculate expected returns and covariance matrix
            expected_returns = returns_df.mean()
            cov_matrix = returns_df.cov()
            
            # Simple Markowitz optimization (equal risk contribution)
            num_assets = len(symbols)
            
            # Risk parity approach - inverse volatility weighting
            volatilities = np.sqrt(np.diag(cov_matrix))
            inv_volatilities = 1 / volatilities
            weights = inv_volatilities / np.sum(inv_volatilities)
            
            # Convert to dictionary
            optimal_weights = {}
            for i, symbol in enumerate(symbols):
                optimal_weights[symbol] = float(weights[i])
            
            logger.info(f"Calculated optimal portfolio weights: {optimal_weights}")
            return optimal_weights
            
        except Exception as e:
            logger.error(f"Error calculating optimal weights: {e}")
            # Return equal weights as fallback
            equal_weight = 1.0 / len(symbols)
            return {symbol: equal_weight for symbol in symbols}
    
    def rebalance_portfolio(self, current_positions: Dict, target_weights: Dict, 
                          total_balance: float) -> Dict[str, float]:
        """T√≠nh to√°n ƒëi·ªÅu ch·ªânh c·∫ßn thi·∫øt ƒë·ªÉ rebalance danh m·ª•c"""
        try:
            rebalance_actions = {}
            
            # Calculate current weights
            total_value = sum(pos['value'] for pos in current_positions.values())
            
            for symbol, target_weight in target_weights.items():
                target_value = total_balance * target_weight
                
                if symbol in current_positions:
                    current_value = current_positions[symbol]['value']
                    difference = target_value - current_value
                else:
                    difference = target_value
                
                # Only rebalance if difference > 5% of target
                if abs(difference) > target_value * 0.05:
                    rebalance_actions[symbol] = difference
            
            return rebalance_actions
            
        except Exception as e:
            logger.error(f"Error calculating rebalance: {e}")
            return {}

# =============================================================================
# TELEGRAM BOT INTERFACE
# =============================================================================

class TelegramBot:
    """Interface Telegram cho bot"""
    
    def __init__(self, signal_generator: SignalGenerator, risk_manager: RiskManager,
                 portfolio_optimizer: PortfolioOptimizer):
        self.signal_generator = signal_generator
        self.risk_manager = risk_manager
        self.portfolio_optimizer = portfolio_optimizer
        self.user_settings = {}  # L∆∞u c√†i ƒë·∫∑t c·ªßa user
        
        # Initialize Telegram Application
        self.application = Application.builder().token(config.TELEGRAM_BOT_TOKEN).build()
        self.setup_handlers()
    
    def setup_handlers(self):
        """Thi·∫øt l·∫≠p c√°c command handlers"""
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("signals", self.signals_command))
        self.application.add_handler(CommandHandler("setpair", self.setpair_command))
        self.application.add_handler(CommandHandler("settings", self.settings_command))
        self.application.add_handler(CommandHandler("performance", self.performance_command))
        self.application.add_handler(CommandHandler("portfolio", self.portfolio_command))
        self.application.add_handler(CallbackQueryHandler(self.button_callback))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /start"""
        user_id = update.effective_user.id
        
        welcome_text = f"""
ü§ñ **Advanced Crypto Trading Bot**

Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot giao d·ªãch crypto th√¥ng minh!

**T√≠nh nƒÉng ch√≠nh:**
‚Ä¢ üìä Ph√¢n t√≠ch k·ªπ thu·∫≠t n√¢ng cao
‚Ä¢ üß† Machine Learning d·ª± ƒëo√°n
‚Ä¢ üì± Ph√¢n t√≠ch t√¢m l√Ω th·ªã tr∆∞·ªùng 
‚Ä¢ ‚öñÔ∏è Qu·∫£n l√Ω r·ªßi ro t·ª± ƒë·ªông
‚Ä¢ üìà T·ªëi ∆∞u h√≥a danh m·ª•c

**B·∫Øt ƒë·∫ßu:**
/help - Xem t·∫•t c·∫£ l·ªánh
/settings - C·∫•u h√¨nh bot
/signals - Xem t√≠n hi·ªáu m·ªõi nh·∫•t

Bot ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi Expert Crypto Trader üöÄ
        """
        
        await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /help"""
        help_text = """
üìö **H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Bot**

**L·ªánh c∆° b·∫£n:**
/start - Kh·ªüi ƒë·ªông bot
/help - Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n
/status - Tr·∫°ng th√°i bot

**Giao d·ªãch:**
/signals - T√≠n hi·ªáu giao d·ªãch m·ªõi nh·∫•t
/setpair BTC/USDT - Theo d√µi c·∫∑p coin c·ª• th·ªÉ
/performance - Xem hi·ªáu su·∫•t giao d·ªãch

**C√†i ƒë·∫∑t:**
/settings - C·∫•u h√¨nh bot
/portfolio - Qu·∫£n l√Ω danh m·ª•c

**Th√¥ng tin t√≠n hi·ªáu:**
‚Ä¢ üü¢ BUY: T√≠n hi·ªáu mua
‚Ä¢ üî¥ SELL: T√≠n hi·ªáu b√°n
‚Ä¢ üìä Confidence: ƒê·ªô tin c·∫≠y (0-100%)
‚Ä¢ üéØ Entry: Gi√° v√†o l·ªánh
‚Ä¢ üõë SL: Stop Loss
‚Ä¢ üí∞ TP: Take Profit

L∆∞u √Ω: Bot ch·ªâ cung c·∫•p t√≠n hi·ªáu, kh√¥ng t·ª± ƒë·ªông giao d·ªãch.
        """
        
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /status"""
        try:
            # Ki·ªÉm tra tr·∫°ng th√°i c√°c components
            status_text = "üîÑ **Tr·∫°ng th√°i Bot**\n\n"
            
            # Database status
            try:
                conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
                conn.close()
                status_text += "‚úÖ Database: Ho·∫°t ƒë·ªông\n"
            except:
                status_text += "‚ùå Database: L·ªói\n"
            
            # Exchange connection
            try:
                binance = self.signal_generator.data_collector.exchanges['binance']
                binance.fetch_ticker('BTC/USDT')
                status_text += "‚úÖ Binance: K·∫øt n·ªëi\n"
            except:
                status_text += "‚ùå Binance: L·ªói k·∫øt n·ªëi\n"
            
            # ML Models
            num_models = len(self.signal_generator.ml_engine.models)
            status_text += f"üß† ML Models: {num_models} trained\n"
            
            # Recent signals
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            cursor.execute('''
                SELECT COUNT(*) FROM signals 
                WHERE timestamp > ?
            ''', (int((datetime.now() - timedelta(hours=24)).timestamp() * 1000),))
            
            signals_24h = cursor.fetchone()[0]
            conn.close()
            
            status_text += f"üìä T√≠n hi·ªáu 24h: {signals_24h}\n"
            status_text += f"‚è∞ C·∫≠p nh·∫≠t: {datetime.now().strftime('%H:%M:%S')}"
            
            await update.message.reply_text(status_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"L·ªói ki·ªÉm tra tr·∫°ng th√°i: {str(e)}")
    
    async def signals_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /signals - Hi·ªÉn th·ªã t√≠n hi·ªáu m·ªõi nh·∫•t"""
        try:
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT symbol, signal_type, entry_price, stop_loss, take_profit,
                       confidence, sentiment_score, timestamp
                FROM signals
                WHERE status = 'active'
                ORDER BY timestamp DESC
                LIMIT 5
            ''')
            
            signals = cursor.fetchall()
            conn.close()
            
            if not signals:
                await update.message.reply_text("Ch∆∞a c√≥ t√≠n hi·ªáu n√†o ƒë∆∞·ª£c t·∫°o.")
                return
            
            signals_text = "üìä **T√≠n hi·ªáu giao d·ªãch m·ªõi nh·∫•t**\n\n"
            
            for signal in signals:
                symbol, signal_type, entry, sl, tp, confidence, sentiment, timestamp = signal
                
                signal_emoji = "üü¢" if signal_type == "BUY" else "üî¥"
                sentiment_emoji = "üòä" if sentiment > 0 else "üòü" if sentiment < 0 else "üòê"
                
                time_str = datetime.fromtimestamp(timestamp/1000).strftime('%H:%M %d/%m')
                
                signals_text += f"{signal_emoji} **{symbol}** - {signal_type}\n"
                signals_text += f"üéØ Entry: ${entry:.4f}\n"
                signals_text += f"üõë SL: ${sl:.4f}\n"
                signals_text += f"üí∞ TP: ${tp:.4f}\n"
                signals_text += f"üìà Confidence: {confidence*100:.1f}%\n"
                signals_text += f"{sentiment_emoji} Sentiment: {sentiment:.2f}\n"
                signals_text += f"‚è∞ {time_str}\n\n"
            
            await update.message.reply_text(signals_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"L·ªói l·∫•y t√≠n hi·ªáu: {str(e)}")
    
    async def setpair_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /setpair - Thi·∫øt l·∫≠p c·∫∑p coin theo d√µi"""
        try:
            if not context.args:
                await update.message.reply_text(
                    "S·ª≠ d·ª•ng: /setpair BTC/USDT\n"
                    "Ho·∫∑c: /setpair BTC/USDT,ETH/USDT,SOL/USDT"
                )
                return
            
            user_id = update.effective_user.id
            pairs_input = context.args[0]
            pairs = [pair.strip().upper() for pair in pairs_input.split(',')]
            
            # Validate pairs
            valid_pairs = []
            for pair in pairs:
                if '/' in pair and len(pair.split('/')) == 2:
                    valid_pairs.append(pair)
            
            if not valid_pairs:
                await update.message.reply_text("ƒê·ªãnh d·∫°ng c·∫∑p coin kh√¥ng h·ª£p l·ªá!")
                return
            
            # Save user settings
            if user_id not in self.user_settings:
                self.user_settings[user_id] = {}
            
            self.user_settings[user_id]['pairs'] = valid_pairs
            
            pairs_text = ", ".join(valid_pairs)
            await update.message.reply_text(
                f"‚úÖ ƒê√£ thi·∫øt l·∫≠p theo d√µi: {pairs_text}\n"
                f"Bot s·∫Ω g·ª≠i t√≠n hi·ªáu cho c√°c c·∫∑p n√†y."
            )
            
        except Exception as e:
            await update.message.reply_text(f"L·ªói thi·∫øt l·∫≠p c·∫∑p coin: {str(e)}")
    
    async def settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /settings - Hi·ªÉn th·ªã v√† c·∫•u h√¨nh settings"""
        keyboard = [
            [InlineKeyboardButton("üìä C·∫∑p coin theo d√µi", callback_data="settings_pairs")],
            [InlineKeyboardButton("‚öñÔ∏è Qu·∫£n l√Ω r·ªßi ro", callback_data="settings_risk")],
            [InlineKeyboardButton("üîî Th√¥ng b√°o", callback_data="settings_alerts")],
            [InlineKeyboardButton("üß† Machine Learning", callback_data="settings_ml")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "‚öôÔ∏è **C√†i ƒë·∫∑t Bot**\n\nCh·ªçn m·ª•c c·∫ßn c·∫•u h√¨nh:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    async def performance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /performance - Hi·ªÉn th·ªã hi·ªáu su·∫•t giao d·ªãch"""
        try:
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            
            # T·ªïng quan hi·ªáu su·∫•t
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_trades,
                    SUM(CASE WHEN pnl_percent > 0 THEN 1 ELSE 0 END) as winning_trades,
                    AVG(pnl_percent) as avg_return,
                    SUM(pnl_percent) as total_return,
                    MAX(pnl_percent) as best_trade,
                    MIN(pnl_percent) as worst_trade
                FROM performance
                WHERE exit_time > ?
            ''', (int((datetime.now() - timedelta(days=30)).timestamp() * 1000),))
            
            stats = cursor.fetchone()
            
            if stats[0] == 0:
                await update.message.reply_text("Ch∆∞a c√≥ d·ªØ li·ªáu giao d·ªãch trong 30 ng√†y qua.")
                return
            
            total_trades, winning_trades, avg_return, total_return, best_trade, worst_trade = stats
            win_rate = (winning_trades / total_trades) * 100
            
            # Hi·ªáu su·∫•t theo symbol
            cursor.execute('''
                SELECT symbol, COUNT(*) as trades, AVG(pnl_percent) as avg_return
                FROM performance
                WHERE exit_time > ?
                GROUP BY symbol
                ORDER BY avg_return DESC
                LIMIT 5
            ''', (int((datetime.now() - timedelta(days=30)).timestamp() * 1000),))
            
            symbol_stats = cursor.fetchall()
            conn.close()
            
            perf_text = f"üìà **Hi·ªáu su·∫•t 30 ng√†y**\n\n"
            perf_text += f"üíº T·ªïng giao d·ªãch: {total_trades}\n"
            perf_text += f"‚úÖ Giao d·ªãch th·∫Øng: {winning_trades}\n"
            perf_text += f"üìä T·ª∑ l·ªá th·∫Øng: {win_rate:.1f}%\n"
            perf_text += f"üí∞ L·ª£i nhu·∫≠n TB: {avg_return:.2f}%\n"
            perf_text += f"üéØ T·ªïng l·ª£i nhu·∫≠n: {total_return:.2f}%\n"
            perf_text += f"üöÄ Giao d·ªãch t·ªët nh·∫•t: {best_trade:.2f}%\n"
            perf_text += f"üìâ Giao d·ªãch t·ªá nh·∫•t: {worst_trade:.2f}%\n\n"
            
            perf_text += "**Top symbols:**\n"
            for symbol, trades, avg_ret in symbol_stats:
                perf_text += f"‚Ä¢ {symbol}: {avg_ret:.2f}% ({trades} trades)\n"
            
            await update.message.reply_text(perf_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"L·ªói l·∫•y d·ªØ li·ªáu hi·ªáu su·∫•t: {str(e)}")
    
    async def portfolio_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /portfolio - Hi·ªÉn th·ªã th√¥ng tin danh m·ª•c"""
        try:
            # Get optimal weights
            symbols = config.DEFAULT_PAIRS
            optimal_weights = self.portfolio_optimizer.calculate_optimal_weights(symbols)
            
            portfolio_text = "üìä **Ph√¢n b·ªï danh m·ª•c t·ªëi ∆∞u**\n\n"
            
            for symbol, weight in optimal_weights.items():
                portfolio_text += f"‚Ä¢ {symbol}: {weight*100:.1f}%\n"
            
            portfolio_text += f"\nüí° D·ª±a tr√™n Modern Portfolio Theory"
            portfolio_text += f"\nüìà T·ªëi ∆∞u h√≥a risk-adjusted return"
            
            await update.message.reply_text(portfolio_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"L·ªói t√≠nh to√°n danh m·ª•c: {str(e)}")
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω callback t·ª´ inline buttons"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "settings_pairs":
            text = "üìä **C·∫∑p coin theo d√µi**\n\n"
            text += "S·ª≠ d·ª•ng l·ªánh: /setpair BTC/USDT,ETH/USDT\n"
            text += "ƒë·ªÉ thi·∫øt l·∫≠p c√°c c·∫∑p coin mu·ªën theo d√µi."
            
        elif query.data == "settings_risk":
            text = "‚öñÔ∏è **Qu·∫£n l√Ω r·ªßi ro**\n\n"
            text += f"‚Ä¢ R·ªßi ro m·ªói l·ªánh: {config.DEFAULT_RISK_PERCENT}%\n"
            text += "‚Ä¢ Trailing stop loss: T·ª± ƒë·ªông\n"
            text += "‚Ä¢ Position sizing: D·ª±a tr√™n ATR\n"
            text += "‚Ä¢ Max positions: 5 c√πng l√∫c"
            
        elif query.data == "settings_alerts":
            text = "üîî **C√†i ƒë·∫∑t th√¥ng b√°o**\n\n"
            text += "‚Ä¢ T√≠n hi·ªáu m·ªõi: B·∫≠t\n"
            text += "‚Ä¢ C·∫≠p nh·∫≠t P&L: B·∫≠t\n"
            text += "‚Ä¢ C·∫£nh b√°o r·ªßi ro: B·∫≠t\n"
            text += "‚Ä¢ B√°o c√°o h√†ng ng√†y: B·∫≠t"
            
        elif query.data == "settings_ml":
            text = "üß† **Machine Learning**\n\n"
            text += "‚Ä¢ Thu·∫≠t to√°n: Random Forest\n"
            text += "‚Ä¢ T√°i hu·∫•n luy·ªán: 24h\n"
            text += "‚Ä¢ Lookback period: 30 ng√†y\n"
            text += "‚Ä¢ Feature selection: T·ª± ƒë·ªông"
        
        else:
            text = "T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn..."
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def send_signal_alert(self, signal: TradingSignal, user_ids: List[int]):
        """G·ª≠i c·∫£nh b√°o t√≠n hi·ªáu cho users"""
        try:
            signal_emoji = "üü¢" if signal.signal_type == "BUY" else "üî¥"
            confidence_emoji = "üî•" if signal.confidence > 0.7 else "‚ö°" if signal.confidence > 0.5 else "üí´"
            
            alert_text = f"{signal_emoji} **T√≠n hi·ªáu m·ªõi - {signal.symbol}**\n\n"
            alert_text += f"üìä **{signal.signal_type}** {confidence_emoji}\n"
            alert_text += f"üéØ Entry: ${signal.entry_price:.4f}\n"
            alert_text += f"üõë Stop Loss: ${signal.stop_loss:.4f}\n"
            alert_text += f"üí∞ Take Profit: ${signal.take_profit:.4f}\n"
            alert_text += f"üìà Confidence: {signal.confidence*100:.1f}%\n"
            alert_text += f"üß† ML Score: {signal.ml_score:.2f}\n"
            alert_text += f"üòä Sentiment: {signal.sentiment_score:.2f}\n"
            alert_text += f"üí° Reason: {signal.reason}\n"
            alert_text += f"‚è∞ {signal.timestamp.strftime('%H:%M:%S')}"
            
            # Risk calculation
            risk_reward = abs(signal.take_profit - signal.entry_price) / abs(signal.entry_price - signal.stop_loss)
            alert_text += f"\nüìä R:R = 1:{risk_reward:.2f}"
            
            for user_id in user_ids:
                try:
                    await self.application.bot.send_message(
                        chat_id=user_id,
                        text=alert_text,
                        parse_mode='Markdown'
                    )
                except Exception as e:
                    logger.error(f"Error sending alert to user {user_id}: {e}")
                    
        except Exception as e:
            logger.error(f"Error sending signal alert: {e}")
    
    def run(self):
        """Ch·∫°y Telegram bot"""
        logger.info("Starting Telegram bot...")
        self.application.run_polling()

# =============================================================================
# MAIN TRADING ENGINE
# =============================================================================

class TradingEngine:
    """Engine ch√≠nh ƒëi·ªÅu ph·ªëi to√†n b·ªô h·ªá th·ªëng"""
    
    def __init__(self):
        self.db_manager = DatabaseManager()
        self.data_collector = DataCollector(self.db_manager)
        self.tech_analyzer = TechnicalAnalyzer(self.db_manager)
        self.ml_engine = MLEngine(self.db_manager)
        self.signal_generator = SignalGenerator(
            self.db_manager, self.data_collector, 
            self.tech_analyzer, self.ml_engine
        )
        self.risk_manager = RiskManager(self.db_manager)
        self.portfolio_optimizer = PortfolioOptimizer(self.db_manager)
        self.telegram_bot = TelegramBot(
            self.signal_generator, self.risk_manager, self.portfolio_optimizer
        )
        
        self.active_positions = {}
        self.is_running = False
        self.user_ids = []  # Danh s√°ch user IDs nh·∫≠n th√¥ng b√°o
    
    async def initialize(self):
        """Kh·ªüi t·∫°o h·ªá th·ªëng"""
        try:
            logger.info("Initializing Trading Engine...")
            
            # Hu·∫•n luy·ªán ML models ban ƒë·∫ßu
            await self.train_initial_models()
            
            # Kh·ªüi t·∫°o data collection
            await self.initial_data_collection()
            
            logger.info("Trading Engine initialized successfully!")
            
        except Exception as e:
            logger.error(f"Error initializing Trading Engine: {e}")
    
    async def train_initial_models(self):
        """Hu·∫•n luy·ªán ML models ban ƒë·∫ßu"""
        logger.info("Training initial ML models...")
        
        for symbol in config.DEFAULT_PAIRS:
            try:
                # Collect training data
                await self.data_collector.collect_price_data(symbol, '1h', limit=500)
                df = self.db_manager.get_price_data(symbol, '1h', limit=500)
                
                if not df.empty:
                    df = self.tech_analyzer.calculate_indicators(df)
                    accuracy = self.ml_engine.train_model(symbol, df)
                    
                    if accuracy > 0.5:
                        logger.info(f"ML model for {symbol} trained with accuracy: {accuracy:.3f}")
                    else:
                        logger.warning(f"Low accuracy for {symbol}: {accuracy:.3f}")
                        
            except Exception as e:
                logger.error(f"Error training model for {symbol}: {e}")
    
    async def initial_data_collection(self):
        """Thu th·∫≠p d·ªØ li·ªáu ban ƒë·∫ßu"""
        logger.info("Collecting initial data...")
        
        for symbol in config.DEFAULT_PAIRS:
            for timeframe in ['5m', '15m', '1h', '4h', '1d']:
                try:
                    await self.data_collector.collect_price_data(symbol, timeframe, limit=100)
                except Exception as e:
                    logger.error(f"Error collecting data for {symbol} {timeframe}: {e}")
    
    async def market_analysis_loop(self):
        """V√≤ng l·∫∑p ph√¢n t√≠ch th·ªã tr∆∞·ªùng"""
        while self.is_running:
            try:
                logger.info("Running market analysis...")
                
                # Ph√¢n t√≠ch t·ª´ng c·∫∑p coin
                for symbol in config.DEFAULT_PAIRS:
                    try:
                        signal = await self.signal_generator.generate_signal(symbol)
                        
                        if signal and signal.confidence > 0.5:
                            # Ki·ªÉm tra risk limits
                            active_positions_list = list(self.active_positions.values())
                            
                            if self.risk_manager.check_risk_limits(signal, active_positions_list):
                                # G·ª≠i t√≠n hi·ªáu
                                await self.telegram_bot.send_signal_alert(signal, self.user_ids)
                                logger.info(f"Signal sent for {symbol}: {signal.signal_type}")
                                
                                # L∆∞u v√†o active positions (simulation)
                                self.active_positions[symbol] = {
                                    'symbol': symbol,
                                    'signal_type': signal.signal_type,
                                    'entry_price': signal.entry_price,
                                    'stop_loss': signal.stop_loss,
                                    'take_profit': signal.take_profit,
                                    'timestamp': signal.timestamp
                                }
                        
                    except Exception as e:
                        logger.error(f"Error analyzing {symbol}: {e}")
                
                # C·∫≠p nh·∫≠t trailing stops
                await self.update_trailing_stops()
                
                # Ngh·ªâ 5 ph√∫t tr∆∞·ªõc khi ph√¢n t√≠ch ti·∫øp
                await asyncio.sleep(300)
                
            except Exception as e:
                logger.error(f"Error in market analysis loop: {e}")
                await asyncio.sleep(60)
    
    async def update_trailing_stops(self):
        """C·∫≠p nh·∫≠t trailing stop loss cho c√°c positions"""
        try:
            for symbol, position in self.active_positions.items():
                # L·∫•y gi√° hi·ªán t·∫°i
                current_price = await self.get_current_price(symbol)
                
                if current_price:
                    new_stop = self.risk_manager.update_trailing_stop(position, current_price)
                    
                    if new_stop != position['stop_loss']:
                        position['stop_loss'] = new_stop
                        logger.info(f"Updated trailing stop for {symbol}: {new_stop}")
                        
                        # G·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t
                        update_text = f"üìä **Trailing Stop Updated**\n"
                        update_text += f"Symbol: {symbol}\n"
                        update_text += f"New Stop Loss: ${new_stop:.4f}\n"
                        update_text += f"Current Price: ${current_price:.4f}"
                        
                        for user_id in self.user_ids:
                            try:
                                await self.telegram_bot.application.bot.send_message(
                                    chat_id=user_id,
                                    text=update_text,
                                    parse_mode='Markdown'
                                )
                            except:
                                pass
                
        except Exception as e:
            logger.error(f"Error updating trailing stops: {e}")
    
    async def get_current_price(self, symbol: str) -> Optional[float]:
        """L·∫•y gi√° hi·ªán t·∫°i c·ªßa symbol"""
        try:
            exchange = self.data_collector.exchanges['binance']
            ticker = exchange.fetch_ticker(symbol)
            return ticker['last']
        except Exception as e:
            logger.error(f"Error getting current price for {symbol}: {e}")
            return None
    
    async def portfolio_rebalance_loop(self):
        """V√≤ng l·∫∑p rebalance danh m·ª•c"""
        while self.is_running:
            try:
                logger.info("Running portfolio rebalance...")
                
                # T√≠nh to√°n tr·ªçng s·ªë t·ªëi ∆∞u
                optimal_weights = self.portfolio_optimizer.calculate_optimal_weights(
                    config.DEFAULT_PAIRS
                )
                
                # G·ª≠i th√¥ng b√°o rebalance recommendation
                rebalance_text = "üìä **Portfolio Rebalance Recommendation**\n\n"
                for symbol, weight in optimal_weights.items():
                    rebalance_text += f"‚Ä¢ {symbol}: {weight*100:.1f}%\n"
                
                for user_id in self.user_ids:
                    try:
                        await self.telegram_bot.application.bot.send_message(
                            chat_id=user_id,
                            text=rebalance_text,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                
                # Ngh·ªâ 8 ti·∫øng tr∆∞·ªõc khi rebalance ti·∫øp
                await asyncio.sleep(config.PORTFOLIO_REBALANCE_HOURS * 3600)
                
            except Exception as e:
                logger.error(f"Error in portfolio rebalance loop: {e}")
                await asyncio.sleep(3600)
    
    async def model_retrain_loop(self):
        """V√≤ng l·∫∑p hu·∫•n luy·ªán l·∫°i ML models"""
        while self.is_running:
            try:
                logger.info("Retraining ML models...")
                
                for symbol in config.DEFAULT_PAIRS:
                    try:
                        # L·∫•y d·ªØ li·ªáu m·ªõi
                        await self.data_collector.collect_price_data(symbol, '1h', limit=500)
                        df = self.db_manager.get_price_data(symbol, '1h', limit=500)
                        
                        if not df.empty:
                            df = self.tech_analyzer.calculate_indicators(df)
                            accuracy = self.ml_engine.train_model(symbol, df)
                            logger.info(f"Retrained {symbol} model, accuracy: {accuracy:.3f}")
                            
                    except Exception as e:
                        logger.error(f"Error retraining model for {symbol}: {e}")
                
                # Ngh·ªâ 24 ti·∫øng tr∆∞·ªõc khi hu·∫•n luy·ªán l·∫°i
                await asyncio.sleep(config.ML_RETRAIN_HOURS * 3600)
                
            except Exception as e:
                logger.error(f"Error in model retrain loop: {e}")
                await asyncio.sleep(3600)
    
    async def daily_report_loop(self):
        """V√≤ng l·∫∑p b√°o c√°o h√†ng ng√†y"""
        while self.is_running:
            try:
                # Ch·ªù ƒë·∫øn 9h s√°ng
                now = datetime.now()
                target_time = now.replace(hour=9, minute=0, second=0, microsecond=0)
                
                if now > target_time:
                    target_time += timedelta(days=1)
                
                wait_seconds = (target_time - now).total_seconds()
                await asyncio.sleep(wait_seconds)
                
                # T·∫°o b√°o c√°o h√†ng ng√†y
                report = await self.generate_daily_report()
                
                for user_id in self.user_ids:
                    try:
                        await self.telegram_bot.application.bot.send_message(
                            chat_id=user_id,
                            text=report,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                
            except Exception as e:
                logger.error(f"Error in daily report loop: {e}")
                await asyncio.sleep(3600)
    
    async def generate_daily_report(self) -> str:
        """T·∫°o b√°o c√°o h√†ng ng√†y"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            # Th·ªëng k√™ 24h qua
            yesterday = int((datetime.now() - timedelta(days=1)).timestamp() * 1000)
            
            cursor.execute('''
                SELECT COUNT(*) as signals, 
                       AVG(confidence) as avg_confidence
                FROM signals
                WHERE timestamp > ?
            ''', (yesterday,))
            
            signal_stats = cursor.fetchone()
            
            cursor.execute('''
                SELECT COUNT(*) as trades,
                       SUM(CASE WHEN pnl_percent > 0 THEN 1 ELSE 0 END) as wins,
                       AVG(pnl_percent) as avg_pnl
                FROM performance
                WHERE exit_time > ?
            ''', (yesterday,))
            
            trade_stats = cursor.fetchone()
            conn.close()
            
            report = f"üìä **B√°o c√°o h√†ng ng√†y - {datetime.now().strftime('%d/%m/%Y')}**\n\n"
            report += f"üîî T√≠n hi·ªáu ph√°t sinh: {signal_stats[0]}\n"
            report += f"üìà Confidence trung b√¨nh: {(signal_stats[1] or 0)*100:.1f}%\n"
            
            if trade_stats[0] > 0:
                win_rate = (trade_stats[1] / trade_stats[0]) * 100
                report += f"üíº Giao d·ªãch: {trade_stats[0]}\n"
                report += f"‚úÖ T·ª∑ l·ªá th·∫Øng: {win_rate:.1f}%\n"
                report += f"üí∞ P&L trung b√¨nh: {trade_stats[2]:.2f}%\n"
            else:
                report += f"üíº Ch∆∞a c√≥ giao d·ªãch n√†o ho√†n th√†nh\n"
            
            # Market overview
            report += f"\nüìä **Th·ªã tr∆∞·ªùng h√¥m nay:**\n"
            for symbol in config.DEFAULT_PAIRS[:3]:
                try:
                    current_price = await self.get_current_price(symbol)
                    if current_price:
                        report += f"‚Ä¢ {symbol}: ${current_price:.4f}\n"
                except:
                    pass
            
            report += f"\nü§ñ Bot ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh!"
            
            return report
            
        except Exception as e:
            logger.error(f"Error generating daily report: {e}")
            return "‚ùå L·ªói t·∫°o b√°o c√°o h√†ng ng√†y"
    
    async def start(self):
        """Kh·ªüi ƒë·ªông h·ªá th·ªëng"""
        self.is_running = True
        
        # Kh·ªüi t·∫°o
        await self.initialize()
        
        # Ch·∫°y c√°c task ƒë·ªìng th·ªùi
        tasks = [
            asyncio.create_task(self.market_analysis_loop()),
            asyncio.create_task(self.portfolio_rebalance_loop()),
            asyncio.create_task(self.model_retrain_loop()),
            asyncio.create_task(self.daily_report_loop())
        ]
        
        # Ch·∫°y Telegram bot trong thread ri√™ng
        import threading
        bot_thread = threading.Thread(target=self.telegram_bot.run)
        bot_thread.daemon = True
        bot_thread.start()
        
        logger.info("üöÄ Trading Engine started successfully!")
        
        # Ch·ªù t·∫•t c·∫£ tasks
        await asyncio.gather(*tasks)
    
    def stop(self):
        """D·ª´ng h·ªá th·ªëng"""
        self.is_running = False
        logger.info("Trading Engine stopped")

# =============================================================================
# SECURITY & UTILITIES
# =============================================================================

class SecurityManager:
    """Qu·∫£n l√Ω b·∫£o m·∫≠t"""
    
    @staticmethod
    def encrypt_api_key(api_key: str, password: str) -> str:
        """M√£ h√≥a API key"""
        try:
            from cryptography.fernet import Fernet
            from cryptography.hazmat.primitives import hashes
            from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
            import base64
            
            # T·∫°o key t·ª´ password
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'crypto_bot_salt',
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
            
            # M√£ h√≥a
            f = Fernet(key)
            encrypted_key = f.encrypt(api_key.encode())
            
            return encrypted_key.decode()
            
        except Exception as e:
            logger.error(f"Error encrypting API key: {e}")
            return api_key
    
    @staticmethod
    def decrypt_api_key(encrypted_key: str, password: str) -> str:
        """Gi·∫£i m√£ API key"""
        try:
            from cryptography.fernet import Fernet
            from cryptography.hazmat.primitives import hashes
            from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
            import base64
            
            # T·∫°o key t·ª´ password
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'crypto_bot_salt',
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
            
            # Gi·∫£i m√£
            f = Fernet(key)
            decrypted_key = f.decrypt(encrypted_key.encode())
            
            return decrypted_key.decode()
            
        except Exception as e:
            logger.error(f"Error decrypting API key: {e}")
            return encrypted_key

class BacktestEngine:
    """Engine backtesting"""
    
    def __init__(self, db_manager: DatabaseManager, tech_analyzer: TechnicalAnalyzer, 
                 ml_engine: MLEngine):
        self.db_manager = db_manager
        self.tech_analyzer = tech_analyzer
        self.ml_engine = ml_engine
    
    def run_backtest(self, symbol: str, start_date: datetime, end_date: datetime, 
                    initial_balance: float = 10000) -> Dict:
        """Ch·∫°y backtest cho m·ªôt symbol"""
        try:
            # L·∫•y d·ªØ li·ªáu l·ªãch s·ª≠
            df = self.db_manager.get_price_data(symbol, '1h', limit=1000)
            
            if df.empty:
                return {'error': 'No historical data available'}
            
            # L·ªçc theo th·ªùi gian
            df = df[(df.index >= start_date) & (df.index <= end_date)]
            
            if len(df) < 100:
                return {'error': 'Insufficient data for backtest period'}
            
            # T√≠nh to√°n indicators
            df = self.tech_analyzer.calculate_indicators(df)
            
            # Hu·∫•n luy·ªán model v·ªõi d·ªØ li·ªáu training
            split_point = int(len(df) * 0.7)
            train_df = df.iloc[:split_point]
            test_df = df.iloc[split_point:]
            
            self.ml_engine.train_model(symbol, train_df)
            
            # Ch·∫°y backtest tr√™n test data
            results = self.simulate_trading(test_df, symbol, initial_balance)
            
            return results
            
        except Exception as e:
            logger.error(f"Error running backtest: {e}")
            return {'error': str(e)}
    
    def simulate_trading(self, df: pd.DataFrame, symbol: str, initial_balance: float) -> Dict:
        """M√¥ ph·ªèng giao d·ªãch"""
        try:
            balance = initial_balance
            positions = []
            trades = []
            
            for i in range(50, len(df)):  # B·∫Øt ƒë·∫ßu t·ª´ index 50 ƒë·ªÉ c√≥ ƒë·ªß d·ªØ li·ªáu
                current_data = df.iloc[:i+1]
                
                # T·∫°o signal (simplified)
                current = current_data.iloc[-1]
                prev = current_data.iloc[-2]
                
                # Simple MA crossover strategy
                if (current['MA_20'] > current['MA_50'] and 
                    prev['MA_20'] <= prev['MA_50'] and 
                    len(positions) == 0):
                    
                    # Buy signal
                    entry_price = current['close']
                    stop_loss = entry_price * 0.98  # 2% stop loss
                    take_profit = entry_price * 1.06  # 6% take profit
                    
                    position = {
                        'type': 'long',
                        'entry_price': entry_price,
                        'entry_time': current_data.index[-1],
                        'stop_loss': stop_loss,
                        'take_profit': take_profit,
                        'size': balance * 0.1 / entry_price  # 10% of balance
                    }
                    positions.append(position)
                
                # Check exit conditions
                if positions:
                    position = positions[0]
                    current_price = current['close']
                    
                    exit_triggered = False
                    exit_reason = ""
                    
                    if current_price <= position['stop_loss']:
                        exit_triggered = True
                        exit_reason = "Stop Loss"
                    elif current_price >= position['take_profit']:
                        exit_triggered = True
                        exit_reason = "Take Profit"
                    
                    if exit_triggered:
                        # Calculate P&L
                        pnl = (current_price - position['entry_price']) * position['size']
                        pnl_percent = (current_price - position['entry_price']) / position['entry_price']
                        
                        balance += pnl
                        
                        trade = {
                            'entry_time': position['entry_time'],
                            'exit_time': current_data.index[-1],
                            'entry_price': position['entry_price'],
                            'exit_price': current_price,
                            'pnl': pnl,
                            'pnl_percent': pnl_percent,
                            'exit_reason': exit_reason
                        }
                        trades.append(trade)
                        positions.clear()
            
            # Calculate results
            if not trades:
                return {'error': 'No trades executed during backtest period'}
            
            total_return = (balance - initial_balance) / initial_balance
            winning_trades = [t for t in trades if t['pnl'] > 0]
            losing_trades = [t for t in trades if t['pnl'] <= 0]
            
            win_rate = len(winning_trades) / len(trades) if trades else 0
            avg_win = np.mean([t['pnl_percent'] for t in winning_trades]) if winning_trades else 0
            avg_loss = np.mean([t['pnl_percent'] for t in losing_trades]) if losing_trades else 0
            
            results = {
                'initial_balance': initial_balance,
                'final_balance': balance,
                'total_return': total_return,
                'total_trades': len(trades),
                'winning_trades': len(winning_trades),
                'losing_trades': len(losing_trades),
                'win_rate': win_rate,
                'avg_win': avg_win,
                'avg_loss': avg_loss,
                'profit_factor': abs(avg_win / avg_loss) if avg_loss != 0 else 0,
                'trades': trades
            }
            
            return results
            
        except Exception as e:
            logger.error(f"Error in trading simulation: {e}")
            return {'error': str(e)}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    """H√†m main ƒë·ªÉ ch·∫°y bot"""
    print("üöÄ Advanced Crypto Trading Bot")
    print("=" * 50)
    
    # Ki·ªÉm tra c·∫•u h√¨nh
    if config.TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("‚ùå L·ªói: Ch∆∞a c·∫•u h√¨nh TELEGRAM_BOT_TOKEN")
        print("Vui l√≤ng c·∫≠p nh·∫≠t config trong file bot")
        return
    
    if config.BINANCE_API_KEY == "YOUR_BINANCE_API_KEY":
        print("‚ùå L·ªói: Ch∆∞a c·∫•u h√¨nh BINANCE_API_KEY")
        print("Vui l√≤ng c·∫≠p nh·∫≠t config trong file bot")
        return
    
    # T·∫°o v√† ch·∫°y trading engine
    engine = TradingEngine()
    
    try:
        # Ch·∫°y engine
        asyncio.run(engine.start())
        
    except KeyboardInterrupt:
        print("\nüõë ƒêang d·ª´ng bot...")
        engine.stop()
        print("‚úÖ Bot ƒë√£ d·ª´ng an to√†n")
        
    except Exception as e:
        logger.error(f"Critical error: {e}")
        print(f"‚ùå L·ªói nghi√™m tr·ªçng: {e}")

if __name__ == "__main__":
    main()

# =============================================================================
# INSTALLATION & SETUP GUIDE
# =============================================================================

"""
üìã H∆Ø·ªöNG D·∫™N C√ÄI ƒê·∫∂T V√Ä THI·∫æT L·∫¨P BOT

1. C√ÄI ƒê·∫∂T TH∆Ø VI·ªÜN:
   pip install ccxt pandas numpy scikit-learn ta tweepy python-telegram-bot
   pip install plotly sqlite3 cryptography asyncio

2. THI·∫æT L·∫¨P API KEYS:
   - T·∫°o bot Telegram qua @BotFather
   - L·∫•y API key t·ª´ Binance (ho·∫∑c s√†n kh√°c)
   - ƒêƒÉng k√Ω Twitter API (t√πy ch·ªçn)
   - C·∫≠p nh·∫≠t config trong file bot

3. CH·∫†Y BOT:
   python crypto_trading_bot.py

4. S·ª¨ D·ª§NG:
   - G·ª≠i /start cho bot tr√™n Telegram
   - Thi·∫øt l·∫≠p c√°c c·∫∑p coin theo d√µi
   - Nh·∫≠n t√≠n hi·ªáu giao d·ªãch t·ª± ƒë·ªông

5. T√çNH NƒÇNG N√ÇNG CAO:
   - Machine Learning t·ª± h·ªçc
   - Qu·∫£n l√Ω r·ªßi ro th√¥ng minh
   - T·ªëi ∆∞u h√≥a danh m·ª•c
   - Ph√¢n t√≠ch sentiment t·ª´ Twitter
   - Backtesting chi·∫øn l∆∞·ª£c

6. B·∫¢O M·∫¨T:
   - Kh√¥ng chia s·∫ª API keys
   - S·ª≠ d·ª•ng VPS ƒë·ªÉ ch·∫°y 24/7
   - B·∫≠t 2FA cho t√†i kho·∫£n s√†n
   - Backup d·ªØ li·ªáu th∆∞·ªùng xuy√™n

7. KHUY·∫æN C√ÅO:
   - Bot ch·ªâ cung c·∫•p t√≠n hi·ªáu, kh√¥ng t·ª± ƒë·ªông giao d·ªãch
   - Lu√¥n ki·ªÉm tra v√† x√°c nh·∫≠n tr∆∞·ªõc khi v√†o l·ªánh
   - Qu·∫£n l√Ω r·ªßi ro c·∫©n th·∫≠n
   - Kh√¥ng ƒë·∫ßu t∆∞ qu√° 5% t·ªïng t√†i s·∫£n v√†o crypto

üöÄ Ch√∫c b·∫°n giao d·ªãch th√†nh c√¥ng!
"""
