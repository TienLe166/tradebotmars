# Advanced Crypto Trading Bot
# Phát triển bởi: Expert Crypto Trader & Python Developer
# Mục tiêu: Bot giao dịch crypto thông minh với AI, quản lý rủi ro nâng cao

import asyncio
import ccxt
import pandas as pd
import numpy as np
import sqlite3
import tweepy
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import json
import hashlib
from dataclasses import dataclass
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import ta
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# =============================================================================
# CONFIGURATION & CONSTANTS
# =============================================================================

@dataclass
class BotConfig:
    """Cấu hình chính của bot"""
    # API Keys (Cần được cấu hình)
    TELEGRAM_BOT_TOKEN: str = "YOUR_TELEGRAM_BOT_TOKEN"
    BINANCE_API_KEY: str = "YOUR_BINANCE_API_KEY"
    BINANCE_SECRET_KEY: str = "YOUR_BINANCE_SECRET_KEY"
    TWITTER_BEARER_TOKEN: str = "YOUR_TWITTER_BEARER_TOKEN"
    
    # Trading Parameters
    DEFAULT_RISK_PERCENT: float = 2.0  # % vốn rủi ro mỗi lệnh
    DEFAULT_PAIRS: List[str] = None
    TIMEFRAMES: List[str] = None
    MIN_VOLUME_USDT: float = 1000000  # Volume tối thiểu
    
    # ML Parameters
    ML_LOOKBACK_DAYS: int = 30
    ML_RETRAIN_HOURS: int = 24
    
    # Portfolio Optimization
    PORTFOLIO_REBALANCE_HOURS: int = 8
    
    def __post_init__(self):
        if self.DEFAULT_PAIRS is None:
            self.DEFAULT_PAIRS = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'ADA/USDT']
        if self.TIMEFRAMES is None:
            self.TIMEFRAMES = ['5m', '15m', '1h', '4h', '1d']

config = BotConfig()

# =============================================================================
# LOGGING SETUP
# =============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('crypto_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# =============================================================================
# DATABASE MANAGER
# =============================================================================

class DatabaseManager:
    """Quản lý cơ sở dữ liệu SQLite"""
    
    def __init__(self, db_path: str = "crypto_bot.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Khởi tạo cơ sở dữ liệu"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Bảng lưu dữ liệu giá
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS price_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                timeframe TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                open REAL NOT NULL,
                high REAL NOT NULL,
                low REAL NOT NULL,
                close REAL NOT NULL,
                volume REAL NOT NULL,
                UNIQUE(symbol, timeframe, timestamp)
            )
        ''')
        
        # Bảng lưu tín hiệu giao dịch
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                signal_type TEXT NOT NULL,
                entry_price REAL NOT NULL,
                stop_loss REAL,
                take_profit REAL,
                confidence REAL NOT NULL,
                sentiment_score REAL,
                ml_score REAL,
                timestamp INTEGER NOT NULL,
                status TEXT DEFAULT 'active'
            )
        ''')
        
        # Bảng lưu dữ liệu sentiment
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sentiment_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                source TEXT NOT NULL,
                sentiment_score REAL NOT NULL,
                text_content TEXT,
                timestamp INTEGER NOT NULL
            )
        ''')
        
        # Bảng lưu hiệu suất
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS performance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                entry_price REAL NOT NULL,
                exit_price REAL NOT NULL,
                pnl_percent REAL NOT NULL,
                pnl_usdt REAL NOT NULL,
                entry_time INTEGER NOT NULL,
                exit_time INTEGER NOT NULL,
                signal_id INTEGER
            )
        ''')
        
        conn.commit()
        conn.close()
        logger.info("Database initialized successfully")
    
    def insert_price_data(self, symbol: str, timeframe: str, ohlcv_data: List):
        """Chèn dữ liệu giá vào database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for data in ohlcv_data:
            try:
                cursor.execute('''
                    INSERT OR REPLACE INTO price_data 
                    (symbol, timeframe, timestamp, open, high, low, close, volume)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (symbol, timeframe, data[0], data[1], data[2], data[3], data[4], data[5]))
            except Exception as e:
                logger.error(f"Error inserting price data: {e}")
        
        conn.commit()
        conn.close()
    
    def get_price_data(self, symbol: str, timeframe: str, limit: int = 100) -> pd.DataFrame:
        """Lấy dữ liệu giá từ database"""
        conn = sqlite3.connect(self.db_path)
        
        query = '''
            SELECT timestamp, open, high, low, close, volume
            FROM price_data
            WHERE symbol = ? AND timeframe = ?
            ORDER BY timestamp DESC
            LIMIT ?
        '''
        
        df = pd.read_sql_query(query, conn, params=(symbol, timeframe, limit))
        conn.close()
        
        if not df.empty:
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)
            df = df.sort_index()
        
        return df

# =============================================================================
# DATA COLLECTOR
# =============================================================================

class DataCollector:
    """Thu thập dữ liệu từ nhiều nguồn"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.exchanges = {}
        self.twitter_client = None
        self.init_exchanges()
        self.init_twitter()
    
    def init_exchanges(self):
        """Khởi tạo kết nối với các sàn giao dịch"""
        try:
            # Binance
            self.exchanges['binance'] = ccxt.binance({
                'apiKey': config.BINANCE_API_KEY,
                'secret': config.BINANCE_SECRET_KEY,
                'sandbox': False,  # Set True for testnet
                'enableRateLimit': True,
            })
            
            # Coinbase Pro
            self.exchanges['coinbase'] = ccxt.coinbasepro({
                'enableRateLimit': True,
            })
            
            # Kraken
            self.exchanges['kraken'] = ccxt.kraken({
                'enableRateLimit': True,
            })
            
            logger.info("Exchanges initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing exchanges: {e}")
    
    def init_twitter(self):
        """Khởi tạo Twitter API cho sentiment analysis"""
        try:
            if config.TWITTER_BEARER_TOKEN:
                self.twitter_client = tweepy.Client(
                    bearer_token=config.TWITTER_BEARER_TOKEN,
                    wait_on_rate_limit=True
                )
                logger.info("Twitter API initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing Twitter API: {e}")
    
    async def collect_price_data(self, symbol: str, timeframe: str = '1h', limit: int = 100):
        """Thu thập dữ liệu giá từ sàn giao dịch"""
        try:
            exchange = self.exchanges['binance']
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            
            # Lưu vào database
            self.db_manager.insert_price_data(symbol, timeframe, ohlcv)
            
            return ohlcv
            
        except Exception as e:
            logger.error(f"Error collecting price data for {symbol}: {e}")
            return []
    
    async def collect_sentiment_data(self, symbol: str) -> float:
        """Thu thập và phân tích sentiment từ Twitter"""
        try:
            if not self.twitter_client:
                return 0.0
            
            # Lấy symbol chính (BTC từ BTC/USDT)
            base_symbol = symbol.split('/')[0]
            
            # Tìm kiếm tweets
            query = f"{base_symbol} crypto OR {base_symbol} price OR #{base_symbol} -is:retweet lang:en"
            tweets = self.twitter_client.search_recent_tweets(
                query=query,
                max_results=50,
                tweet_fields=['created_at', 'public_metrics']
            )
            
            if not tweets.data:
                return 0.0
            
            # Phân tích sentiment đơn giản
            sentiment_scores = []
            positive_words = ['bull', 'bullish', 'moon', 'pump', 'buy', 'long', 'hodl', 'up', 'rise', 'gain']
            negative_words = ['bear', 'bearish', 'dump', 'sell', 'short', 'crash', 'down', 'fall', 'loss']
            
            for tweet in tweets.data:
                text = tweet.text.lower()
                positive_count = sum(1 for word in positive_words if word in text)
                negative_count = sum(1 for word in negative_words if word in text)
                
                if positive_count > 0 or negative_count > 0:
                    score = (positive_count - negative_count) / (positive_count + negative_count + 1)
                    # Trọng số theo engagement
                    weight = (tweet.public_metrics['like_count'] + 
                             tweet.public_metrics['retweet_count'] + 1)
                    sentiment_scores.append(score * np.log(weight))
            
            if sentiment_scores:
                avg_sentiment = np.mean(sentiment_scores)
                # Chuẩn hóa về [-1, 1]
                return np.tanh(avg_sentiment)
            
            return 0.0
            
        except Exception as e:
            logger.error(f"Error collecting sentiment data: {e}")
            return 0.0
    
    def get_best_exchange_price(self, symbol: str, side: str = 'buy') -> Tuple[str, float]:
        """Tìm sàn có giá tốt nhất"""
        best_exchange = None
        best_price = None
        
        for exchange_name, exchange in self.exchanges.items():
            try:
                ticker = exchange.fetch_ticker(symbol)
                price = ticker['bid'] if side == 'sell' else ticker['ask']
                
                if best_price is None or (
                    (side == 'buy' and price < best_price) or
                    (side == 'sell' and price > best_price)
                ):
                    best_price = price
                    best_exchange = exchange_name
                    
            except Exception as e:
                logger.warning(f"Error fetching price from {exchange_name}: {e}")
        
        return best_exchange, best_price

# =============================================================================
# TECHNICAL ANALYSIS ENGINE
# =============================================================================

class TechnicalAnalyzer:
    """Phân tích kỹ thuật nâng cao"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Tính toán các chỉ báo kỹ thuật"""
        try:
            # Moving Averages
            df['MA_20'] = df['close'].rolling(window=20).mean()
            df['MA_50'] = df['close'].rolling(window=50).mean()
            df['MA_100'] = df['close'].rolling(window=100).mean()
            df['MA_200'] = df['close'].rolling(window=200).mean()
            
            # Exponential Moving Averages
            df['EMA_12'] = df['close'].ewm(span=12).mean()
            df['EMA_26'] = df['close'].ewm(span=26).mean()
            
            # MACD
            df['MACD'] = df['EMA_12'] - df['EMA_26']
            df['MACD_signal'] = df['MACD'].ewm(span=9).mean()
            df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
            
            # RSI
            df['RSI'] = ta.momentum.RSIIndicator(df['close'], window=14).rsi()
            
            # Bollinger Bands
            bb_indicator = ta.volatility.BollingerBands(df['close'], window=20, window_dev=2)
            df['BB_upper'] = bb_indicator.bollinger_hband()
            df['BB_middle'] = bb_indicator.bollinger_mavg()
            df['BB_lower'] = bb_indicator.bollinger_lband()
            df['BB_width'] = (df['BB_upper'] - df['BB_lower']) / df['BB_middle']
            
            # ATR (Average True Range)
            df['ATR'] = ta.volatility.AverageTrueRange(
                df['high'], df['low'], df['close'], window=14
            ).average_true_range()
            
            # Volume indicators
            df['Volume_MA'] = df['volume'].rolling(window=20).mean()
            df['Volume_ratio'] = df['volume'] / df['Volume_MA']
            
            # Stochastic
            stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'])
            df['Stoch_K'] = stoch.stoch()
            df['Stoch_D'] = stoch.stoch_signal()
            
            # Williams %R
            df['Williams_R'] = ta.momentum.WilliamsRIndicator(
                df['high'], df['low'], df['close'], lbp=14
            ).williams_r()
            
            # Commodity Channel Index
            df['CCI'] = ta.trend.CCIIndicator(
                df['high'], df['low'], df['close'], window=20
            ).cci()
            
            # Support and Resistance levels
            df = self.calculate_support_resistance(df)
            
            return df
            
        except Exception as e:
            logger.error(f"Error calculating indicators: {e}")
            return df
    
    def calculate_support_resistance(self, df: pd.DataFrame, window: int = 20) -> pd.DataFrame:
        """Tính toán mức hỗ trợ và kháng cự"""
        try:
            # Tìm local highs và lows
            df['local_high'] = df['high'].rolling(window=window, center=True).max() == df['high']
            df['local_low'] = df['low'].rolling(window=window, center=True).min() == df['low']
            
            # Tính toán mức hỗ trợ và kháng cự gần nhất
            resistance_levels = df[df['local_high']]['high'].tail(3).values
            support_levels = df[df['local_low']]['low'].tail(3).values
            
            if len(resistance_levels) > 0:
                df['resistance'] = np.max(resistance_levels)
            else:
                df['resistance'] = df['high'].max()
                
            if len(support_levels) > 0:
                df['support'] = np.min(support_levels)
            else:
                df['support'] = df['low'].min()
            
            return df
            
        except Exception as e:
            logger.error(f"Error calculating support/resistance: {e}")
            return df
    
    def detect_patterns(self, df: pd.DataFrame) -> Dict:
        """Phát hiện các mẫu giá cổ điển"""
        patterns = {
            'golden_cross': False,
            'death_cross': False,
            'bullish_divergence': False,
            'bearish_divergence': False,
            'hammer': False,
            'doji': False,
            'engulfing_bull': False,
            'engulfing_bear': False
        }
        
        try:
            if len(df) < 50:
                return patterns
            
            # Golden Cross và Death Cross
            if df['MA_50'].iloc[-2] <= df['MA_200'].iloc[-2] and df['MA_50'].iloc[-1] > df['MA_200'].iloc[-1]:
                patterns['golden_cross'] = True
            elif df['MA_50'].iloc[-2] >= df['MA_200'].iloc[-2] and df['MA_50'].iloc[-1] < df['MA_200'].iloc[-1]:
                patterns['death_cross'] = True
            
            # MACD Divergence
            price_trend = (df['close'].iloc[-1] - df['close'].iloc[-10]) / df['close'].iloc[-10]
            macd_trend = (df['MACD'].iloc[-1] - df['MACD'].iloc[-10]) / abs(df['MACD'].iloc[-10] + 0.0001)
            
            if price_trend < 0 and macd_trend > 0:  # Giá giảm nhưng MACD tăng
                patterns['bullish_divergence'] = True
            elif price_trend > 0 and macd_trend < 0:  # Giá tăng nhưng MACD giảm
                patterns['bearish_divergence'] = True
            
            # Candlestick patterns
            current = df.iloc[-1]
            previous = df.iloc[-2]
            
            # Hammer pattern
            body_size = abs(current['close'] - current['open'])
            upper_shadow = current['high'] - max(current['close'], current['open'])
            lower_shadow = min(current['close'], current['open']) - current['low']
            
            if lower_shadow > 2 * body_size and upper_shadow < body_size:
                patterns['hammer'] = True
            
            # Doji pattern
            if body_size < (current['high'] - current['low']) * 0.1:
                patterns['doji'] = True
            
            # Engulfing patterns
            if (previous['close'] < previous['open'] and  # Previous bearish
                current['close'] > current['open'] and   # Current bullish
                current['open'] < previous['close'] and  # Opens below previous close
                current['close'] > previous['open']):    # Closes above previous open
                patterns['engulfing_bull'] = True
            
            elif (previous['close'] > previous['open'] and  # Previous bullish
                  current['close'] < current['open'] and   # Current bearish
                  current['open'] > previous['close'] and  # Opens above previous close
                  current['close'] < previous['open']):    # Closes below previous open
                patterns['engulfing_bear'] = True
            
        except Exception as e:
            logger.error(f"Error detecting patterns: {e}")
        
        return patterns

# =============================================================================
# MACHINE LEARNING ENGINE
# =============================================================================

class MLEngine:
    """Machine Learning cho dự đoán xu hướng"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.models = {}
        self.scalers = {}
    
    def prepare_features(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """Chuẩn bị features cho ML model"""
        try:
            # Features selection
            feature_columns = [
                'RSI', 'MACD', 'MACD_signal', 'BB_width', 'ATR',
                'Volume_ratio', 'Stoch_K', 'Stoch_D', 'Williams_R', 'CCI'
            ]
            
            # Thêm các features từ price action
            df['price_change_5'] = df['close'].pct_change(5)
            df['price_change_10'] = df['close'].pct_change(10)
            df['high_low_ratio'] = (df['high'] - df['low']) / df['close']
            df['close_position'] = (df['close'] - df['low']) / (df['high'] - df['low'])
            
            feature_columns.extend(['price_change_5', 'price_change_10', 'high_low_ratio', 'close_position'])
            
            # Target: Price movement trong 5 periods tiếp theo
            df['future_return'] = df['close'].shift(-5).pct_change()
            df['target'] = (df['future_return'] > 0.02).astype(int)  # 2% threshold
            
            # Remove NaN values
            df_clean = df.dropna()
            
            if len(df_clean) < 50:
                return None, None
            
            X = df_clean[feature_columns].values
            y = df_clean['target'].values
            
            return X, y
            
        except Exception as e:
            logger.error(f"Error preparing features: {e}")
            return None, None
    
    def train_model(self, symbol: str, df: pd.DataFrame) -> float:
        """Huấn luyện ML model cho symbol cụ thể"""
        try:
            X, y = self.prepare_features(df)
            
            if X is None or len(X) < 100:
                logger.warning(f"Insufficient data for training {symbol}")
                return 0.0
            
            # Split data
            split_idx = int(len(X) * 0.8)
            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]
            
            # Scale features
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            # Train Random Forest
            model = RandomForestClassifier(
                n_estimators=100,
                max_depth=10,
                min_samples_split=5,
                min_samples_leaf=2,
                random_state=42
            )
            
            model.fit(X_train_scaled, y_train)
            
            # Evaluate
            accuracy = model.score(X_test_scaled, y_test)
            
            # Save model and scaler
            self.models[symbol] = model
            self.scalers[symbol] = scaler
            
            logger.info(f"ML model trained for {symbol} with accuracy: {accuracy:.3f}")
            return accuracy
            
        except Exception as e:
            logger.error(f"Error training ML model for {symbol}: {e}")
            return 0.0
    
    def predict_signal(self, symbol: str, df: pd.DataFrame) -> Tuple[float, float]:
        """Dự đoán tín hiệu giao dịch"""
        try:
            if symbol not in self.models:
                logger.warning(f"No ML model found for {symbol}")
                return 0.0, 0.0
            
            X, _ = self.prepare_features(df)
            
            if X is None or len(X) == 0:
                return 0.0, 0.0
            
            # Get latest features
            latest_features = X[-1].reshape(1, -1)
            
            # Scale features
            scaler = self.scalers[symbol]
            latest_features_scaled = scaler.transform(latest_features)
            
            # Predict
            model = self.models[symbol]
            probability = model.predict_proba(latest_features_scaled)[0]
            
            # Return probability of bullish signal and confidence
            bullish_prob = probability[1] if len(probability) > 1 else 0.0
            confidence = max(probability) - min(probability) if len(probability) > 1 else 0.0
            
            return bullish_prob, confidence
            
        except Exception as e:
            logger.error(f"Error predicting with ML model: {e}")
            return 0.0, 0.0

# =============================================================================
# SIGNAL GENERATOR
# =============================================================================

@dataclass
class TradingSignal:
    """Cấu trúc tín hiệu giao dịch"""
    symbol: str
    signal_type: str  # 'BUY' hoặc 'SELL'
    entry_price: float
    stop_loss: float
    take_profit: float
    confidence: float
    sentiment_score: float
    ml_score: float
    reason: str
    timestamp: datetime

class SignalGenerator:
    """Tạo ra tín hiệu giao dịch dựa trên phân tích tổng hợp"""
    
    def __init__(self, db_manager: DatabaseManager, data_collector: DataCollector, 
                 tech_analyzer: TechnicalAnalyzer, ml_engine: MLEngine):
        self.db_manager = db_manager
        self.data_collector = data_collector
        self.tech_analyzer = tech_analyzer
        self.ml_engine = ml_engine
    
    async def generate_signal(self, symbol: str, timeframe: str = '1h') -> Optional[TradingSignal]:
        """Tạo tín hiệu giao dịch cho một symbol"""
        try:
            # Lấy dữ liệu giá
            await self.data_collector.collect_price_data(symbol, timeframe, limit=200)
            df = self.db_manager.get_price_data(symbol, timeframe, limit=200)
            
            if df.empty or len(df) < 100:
                logger.warning(f"Insufficient price data for {symbol}")
                return None
            
            # Tính toán chỉ báo kỹ thuật
            df = self.tech_analyzer.calculate_indicators(df)
            
            # Phát hiện patterns
            patterns = self.tech_analyzer.detect_patterns(df)
            
            # Thu thập sentiment
            sentiment_score = await self.data_collector.collect_sentiment_data(symbol)
            
            # ML prediction
            ml_score, ml_confidence = self.ml_engine.predict_signal(symbol, df)
            
            # Tính toán tín hiệu tổng hợp
            signal = self.calculate_composite_signal(df, patterns, sentiment_score, ml_score, ml_confidence)
            
            if signal:
                signal.symbol = symbol
                signal.sentiment_score = sentiment_score
                signal.ml_score = ml_score
                
                # Lưu vào database
                await self.save_signal(signal)
                
                logger.info(f"Generated signal for {symbol}: {signal.signal_type} at {signal.entry_price}")
                
            return signal
            
        except Exception as e:
            logger.error(f"Error generating signal for {symbol}: {e}")
            return None
    
    def calculate_composite_signal(self, df: pd.DataFrame, patterns: Dict, 
                                 sentiment_score: float, ml_score: float, 
                                 ml_confidence: float) -> Optional[TradingSignal]:
        """Tính toán tín hiệu tổng hợp từ nhiều nguồn"""
        try:
            current = df.iloc[-1]
            prev = df.iloc[-2]
            
            # Technical Analysis Score
            tech_score = 0
            reasons = []
            
            # Moving Average signals
            if current['close'] > current['MA_20'] > current['MA_50']:
                tech_score += 0.2
                reasons.append("Price above MA20>MA50")
            elif current['close'] < current['MA_20'] < current['MA_50']:
                tech_score -= 0.2
                reasons.append("Price below MA20<MA50")
            
            # MACD signals
            if current['MACD'] > current['MACD_signal'] and prev['MACD'] <= prev['MACD_signal']:
                tech_score += 0.3
                reasons.append("MACD bullish crossover")
            elif current['MACD'] < current['MACD_signal'] and prev['MACD'] >= prev['MACD_signal']:
                tech_score -= 0.3
                reasons.append("MACD bearish crossover")
            
            # RSI signals
            if current['RSI'] < 30 and prev['RSI'] >= 30:
                tech_score += 0.2
                reasons.append("RSI oversold recovery")
            elif current['RSI'] > 70 and prev['RSI'] <= 70:
                tech_score -= 0.2
                reasons.append("RSI overbought")
            
            # Bollinger Bands signals
            if current['close'] <= current['BB_lower'] and prev['close'] > prev['BB_lower']:
                tech_score += 0.15
                reasons.append("Price touching lower BB")
            elif current['close'] >= current['BB_upper'] and prev['close'] < prev['BB_upper']:
                tech_score -= 0.15
                reasons.append("Price touching upper BB")
            
            # Pattern signals
            if patterns['golden_cross']:
                tech_score += 0.4
                reasons.append("Golden cross detected")
            elif patterns['death_cross']:
                tech_score -= 0.4
                reasons.append("Death cross detected")
            
            if patterns['bullish_divergence']:
                tech_score += 0.3
                reasons.append("Bullish divergence")
            elif patterns['bearish_divergence']:
                tech_score -= 0.3
                reasons.append("Bearish divergence")
            
            if patterns['hammer'] or patterns['engulfing_bull']:
                tech_score += 0.2
                reasons.append("Bullish candlestick pattern")
            elif patterns['engulfing_bear']:
                tech_score -= 0.2
                reasons.append("Bearish candlestick pattern")
            
            # Volume confirmation
            if current['Volume_ratio'] > 1.5:
                tech_score *= 1.2  # Boost signal with high volume
                reasons.append("High volume confirmation")
            
            # Tính toán điểm tổng hợp
            # Trọng số: Technical 40%, Sentiment 25%, ML 35%
            composite_score = (tech_score * 0.4 + 
                             sentiment_score * 0.25 + 
                             (ml_score - 0.5) * 0.35)
            
            # Confidence calculation
            confidence = (abs(tech_score) * 0.4 + 
                         abs(sentiment_score) * 0.25 + 
                         ml_confidence * 0.35)
            
            # Threshold cho tín hiệu
            if composite_score > 0.3 and confidence > 0.4:
                signal_type = "BUY"
            elif composite_score < -0.3 and confidence > 0.4:
                signal_type = "SELL"
            else:
                return None
            
            # Tính toán entry, stop loss, take profit
            entry_price = current['close']
            atr = current['ATR']
            
            if signal_type == "BUY":
                stop_loss = entry_price - (atr * 2)
                take_profit = entry_price + (atr * 3)
            else:
                stop_loss = entry_price + (atr * 2)
                take_profit = entry_price - (atr * 3)
            
            return TradingSignal(
                symbol="",  # Will be set by caller
                signal_type=signal_type,
                entry_price=entry_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                confidence=confidence,
                sentiment_score=sentiment_score,
                ml_score=ml_score,
                reason=" | ".join(reasons[:3]),  # Top 3 reasons
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Error calculating composite signal: {e}")
            return None
    
    async def save_signal(self, signal: TradingSignal):
        """Lưu tín hiệu vào database"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO signals 
                (symbol, signal_type, entry_price, stop_loss, take_profit, 
                 confidence, sentiment_score, ml_score, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                signal.symbol, signal.signal_type, signal.entry_price,
                signal.stop_loss, signal.take_profit, signal.confidence,
                signal.sentiment_score, signal.ml_score,
                int(signal.timestamp.timestamp() * 1000)
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error saving signal: {e}")

# =============================================================================
# RISK MANAGEMENT
# =============================================================================

class RiskManager:
    """Quản lý rủi ro nâng cao"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.max_risk_per_trade = config.DEFAULT_RISK_PERCENT / 100
        self.max_portfolio_risk = 0.1  # 10% tổng vốn
        self.max_daily_loss = 0.05  # 5% vốn mỗi ngày
    
    def calculate_position_size(self, signal: TradingSignal, account_balance: float) -> float:
        """Tính toán kích thước vị thế dựa trên rủi ro"""
        try:
            # Risk per trade based on stop loss
            risk_per_share = abs(signal.entry_price - signal.stop_loss)
            risk_amount = account_balance * self.max_risk_per_trade
            
            # Position size calculation
            position_size = risk_amount / risk_per_share
            
            # Adjust based on confidence
            confidence_multiplier = min(signal.confidence * 1.5, 1.2)
            position_size *= confidence_multiplier
            
            # Maximum position size (no more than 20% of balance)
            max_position_value = account_balance * 0.2
            max_shares = max_position_value / signal.entry_price
            
            position_size = min(position_size, max_shares)
            
            logger.info(f"Calculated position size: {position_size:.6f} for {signal.symbol}")
            return max(position_size, 0)
            
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return 0
    
    def check_risk_limits(self, new_signal: TradingSignal, active_positions: List) -> bool:
        """Kiểm tra giới hạn rủi ro trước khi vào lệnh"""
        try:
            # Kiểm tra số lượng positions đang mở
            if len(active_positions) >= 5:  # Max 5 positions
                logger.warning("Maximum number of positions reached")
                return False
            
            # Kiểm tra correlation giữa các symbols
            symbols = [pos['symbol'] for pos in active_positions]
            if new_signal.symbol in symbols:
                logger.warning(f"Already have position in {new_signal.symbol}")
                return False
            
            # Kiểm tra daily loss limit
            today_pnl = self.get_today_pnl()
            if today_pnl < -self.max_daily_loss:
                logger.warning("Daily loss limit reached")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error checking risk limits: {e}")
            return False
    
    def get_today_pnl(self) -> float:
        """Lấy P&L của ngày hôm nay"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
            today_timestamp = int(today_start.timestamp() * 1000)
            
            cursor.execute('''
                SELECT SUM(pnl_percent) as total_pnl
                FROM performance
                WHERE exit_time >= ?
            ''', (today_timestamp,))
            
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result[0] else 0.0
            
        except Exception as e:
            logger.error(f"Error getting today PnL: {e}")
            return 0.0
    
    def update_trailing_stop(self, position: Dict, current_price: float) -> float:
        """Cập nhật trailing stop loss"""
        try:
            entry_price = position['entry_price']
            current_stop = position['stop_loss']
            signal_type = position['signal_type']
            
            if signal_type == "BUY":
                # For long positions
                price_change = (current_price - entry_price) / entry_price
                
                if price_change > 0.02:  # 2% profit
                    # Move stop loss to break even
                    new_stop = max(current_stop, entry_price)
                    
                if price_change > 0.05:  # 5% profit
                    # Trail stop at 50% of profit
                    new_stop = entry_price + (current_price - entry_price) * 0.5
                    new_stop = max(current_stop, new_stop)
                else:
                    new_stop = current_stop
            
            else:  # SELL position
                price_change = (entry_price - current_price) / entry_price
                
                if price_change > 0.02:  # 2% profit
                    new_stop = min(current_stop, entry_price)
                    
                if price_change > 0.05:  # 5% profit
                    new_stop = entry_price - (entry_price - current_price) * 0.5
                    new_stop = min(current_stop, new_stop)
                else:
                    new_stop = current_stop
            
            return new_stop
            
        except Exception as e:
            logger.error(f"Error updating trailing stop: {e}")
            return position['stop_loss']

# =============================================================================
# PORTFOLIO OPTIMIZER
# =============================================================================

class PortfolioOptimizer:
    """Tối ưu hóa danh mục đầu tư theo Modern Portfolio Theory"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def calculate_optimal_weights(self, symbols: List[str], lookback_days: int = 30) -> Dict[str, float]:
        """Tính toán trọng số tối ưu cho danh mục"""
        try:
            # Lấy dữ liệu returns
            returns_data = {}
            
            for symbol in symbols:
                df = self.db_manager.get_price_data(symbol, '1d', limit=lookback_days)
                if not df.empty:
                    returns = df['close'].pct_change().dropna()
                    returns_data[symbol] = returns
            
            if len(returns_data) < 2:
                # Equal weights if insufficient data
                equal_weight = 1.0 / len(symbols)
                return {symbol: equal_weight for symbol in symbols}
            
            # Create returns matrix
            returns_df = pd.DataFrame(returns_data)
            returns_df = returns_df.dropna()
            
            if len(returns_df) < 10:
                equal_weight = 1.0 / len(symbols)
                return {symbol: equal_weight for symbol in symbols}
            
            # Calculate expected returns and covariance matrix
            expected_returns = returns_df.mean()
            cov_matrix = returns_df.cov()
            
            # Simple Markowitz optimization (equal risk contribution)
            num_assets = len(symbols)
            
            # Risk parity approach - inverse volatility weighting
            volatilities = np.sqrt(np.diag(cov_matrix))
            inv_volatilities = 1 / volatilities
            weights = inv_volatilities / np.sum(inv_volatilities)
            
            # Convert to dictionary
            optimal_weights = {}
            for i, symbol in enumerate(symbols):
                optimal_weights[symbol] = float(weights[i])
            
            logger.info(f"Calculated optimal portfolio weights: {optimal_weights}")
            return optimal_weights
            
        except Exception as e:
            logger.error(f"Error calculating optimal weights: {e}")
            # Return equal weights as fallback
            equal_weight = 1.0 / len(symbols)
            return {symbol: equal_weight for symbol in symbols}
    
    def rebalance_portfolio(self, current_positions: Dict, target_weights: Dict, 
                          total_balance: float) -> Dict[str, float]:
        """Tính toán điều chỉnh cần thiết để rebalance danh mục"""
        try:
            rebalance_actions = {}
            
            # Calculate current weights
            total_value = sum(pos['value'] for pos in current_positions.values())
            
            for symbol, target_weight in target_weights.items():
                target_value = total_balance * target_weight
                
                if symbol in current_positions:
                    current_value = current_positions[symbol]['value']
                    difference = target_value - current_value
                else:
                    difference = target_value
                
                # Only rebalance if difference > 5% of target
                if abs(difference) > target_value * 0.05:
                    rebalance_actions[symbol] = difference
            
            return rebalance_actions
            
        except Exception as e:
            logger.error(f"Error calculating rebalance: {e}")
            return {}

# =============================================================================
# TELEGRAM BOT INTERFACE
# =============================================================================

class TelegramBot:
    """Interface Telegram cho bot"""
    
    def __init__(self, signal_generator: SignalGenerator, risk_manager: RiskManager,
                 portfolio_optimizer: PortfolioOptimizer):
        self.signal_generator = signal_generator
        self.risk_manager = risk_manager
        self.portfolio_optimizer = portfolio_optimizer
        self.user_settings = {}  # Lưu cài đặt của user
        
        # Initialize Telegram Application
        self.application = Application.builder().token(config.TELEGRAM_BOT_TOKEN).build()
        self.setup_handlers()
    
    def setup_handlers(self):
        """Thiết lập các command handlers"""
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("signals", self.signals_command))
        self.application.add_handler(CommandHandler("setpair", self.setpair_command))
        self.application.add_handler(CommandHandler("settings", self.settings_command))
        self.application.add_handler(CommandHandler("performance", self.performance_command))
        self.application.add_handler(CommandHandler("portfolio", self.portfolio_command))
        self.application.add_handler(CallbackQueryHandler(self.button_callback))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /start"""
        user_id = update.effective_user.id
        
        welcome_text = f"""
🤖 **Advanced Crypto Trading Bot**

Chào mừng bạn đến với bot giao dịch crypto thông minh!

**Tính năng chính:**
• 📊 Phân tích kỹ thuật nâng cao
• 🧠 Machine Learning dự đoán
• 📱 Phân tích tâm lý thị trường 
• ⚖️ Quản lý rủi ro tự động
• 📈 Tối ưu hóa danh mục

**Bắt đầu:**
/help - Xem tất cả lệnh
/settings - Cấu hình bot
/signals - Xem tín hiệu mới nhất

Bot được phát triển bởi Expert Crypto Trader 🚀
        """
        
        await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /help"""
        help_text = """
📚 **Hướng dẫn sử dụng Bot**

**Lệnh cơ bản:**
/start - Khởi động bot
/help - Hiển thị hướng dẫn
/status - Trạng thái bot

**Giao dịch:**
/signals - Tín hiệu giao dịch mới nhất
/setpair BTC/USDT - Theo dõi cặp coin cụ thể
/performance - Xem hiệu suất giao dịch

**Cài đặt:**
/settings - Cấu hình bot
/portfolio - Quản lý danh mục

**Thông tin tín hiệu:**
• 🟢 BUY: Tín hiệu mua
• 🔴 SELL: Tín hiệu bán
• 📊 Confidence: Độ tin cậy (0-100%)
• 🎯 Entry: Giá vào lệnh
• 🛑 SL: Stop Loss
• 💰 TP: Take Profit

Lưu ý: Bot chỉ cung cấp tín hiệu, không tự động giao dịch.
        """
        
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /status"""
        try:
            # Kiểm tra trạng thái các components
            status_text = "🔄 **Trạng thái Bot**\n\n"
            
            # Database status
            try:
                conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
                conn.close()
                status_text += "✅ Database: Hoạt động\n"
            except:
                status_text += "❌ Database: Lỗi\n"
            
            # Exchange connection
            try:
                binance = self.signal_generator.data_collector.exchanges['binance']
                binance.fetch_ticker('BTC/USDT')
                status_text += "✅ Binance: Kết nối\n"
            except:
                status_text += "❌ Binance: Lỗi kết nối\n"
            
            # ML Models
            num_models = len(self.signal_generator.ml_engine.models)
            status_text += f"🧠 ML Models: {num_models} trained\n"
            
            # Recent signals
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            cursor.execute('''
                SELECT COUNT(*) FROM signals 
                WHERE timestamp > ?
            ''', (int((datetime.now() - timedelta(hours=24)).timestamp() * 1000),))
            
            signals_24h = cursor.fetchone()[0]
            conn.close()
            
            status_text += f"📊 Tín hiệu 24h: {signals_24h}\n"
            status_text += f"⏰ Cập nhật: {datetime.now().strftime('%H:%M:%S')}"
            
            await update.message.reply_text(status_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"Lỗi kiểm tra trạng thái: {str(e)}")
    
    async def signals_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /signals - Hiển thị tín hiệu mới nhất"""
        try:
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT symbol, signal_type, entry_price, stop_loss, take_profit,
                       confidence, sentiment_score, timestamp
                FROM signals
                WHERE status = 'active'
                ORDER BY timestamp DESC
                LIMIT 5
            ''')
            
            signals = cursor.fetchall()
            conn.close()
            
            if not signals:
                await update.message.reply_text("Chưa có tín hiệu nào được tạo.")
                return
            
            signals_text = "📊 **Tín hiệu giao dịch mới nhất**\n\n"
            
            for signal in signals:
                symbol, signal_type, entry, sl, tp, confidence, sentiment, timestamp = signal
                
                signal_emoji = "🟢" if signal_type == "BUY" else "🔴"
                sentiment_emoji = "😊" if sentiment > 0 else "😟" if sentiment < 0 else "😐"
                
                time_str = datetime.fromtimestamp(timestamp/1000).strftime('%H:%M %d/%m')
                
                signals_text += f"{signal_emoji} **{symbol}** - {signal_type}\n"
                signals_text += f"🎯 Entry: ${entry:.4f}\n"
                signals_text += f"🛑 SL: ${sl:.4f}\n"
                signals_text += f"💰 TP: ${tp:.4f}\n"
                signals_text += f"📈 Confidence: {confidence*100:.1f}%\n"
                signals_text += f"{sentiment_emoji} Sentiment: {sentiment:.2f}\n"
                signals_text += f"⏰ {time_str}\n\n"
            
            await update.message.reply_text(signals_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"Lỗi lấy tín hiệu: {str(e)}")
    
    async def setpair_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /setpair - Thiết lập cặp coin theo dõi"""
        try:
            if not context.args:
                await update.message.reply_text(
                    "Sử dụng: /setpair BTC/USDT\n"
                    "Hoặc: /setpair BTC/USDT,ETH/USDT,SOL/USDT"
                )
                return
            
            user_id = update.effective_user.id
            pairs_input = context.args[0]
            pairs = [pair.strip().upper() for pair in pairs_input.split(',')]
            
            # Validate pairs
            valid_pairs = []
            for pair in pairs:
                if '/' in pair and len(pair.split('/')) == 2:
                    valid_pairs.append(pair)
            
            if not valid_pairs:
                await update.message.reply_text("Định dạng cặp coin không hợp lệ!")
                return
            
            # Save user settings
            if user_id not in self.user_settings:
                self.user_settings[user_id] = {}
            
            self.user_settings[user_id]['pairs'] = valid_pairs
            
            pairs_text = ", ".join(valid_pairs)
            await update.message.reply_text(
                f"✅ Đã thiết lập theo dõi: {pairs_text}\n"
                f"Bot sẽ gửi tín hiệu cho các cặp này."
            )
            
        except Exception as e:
            await update.message.reply_text(f"Lỗi thiết lập cặp coin: {str(e)}")
    
    async def settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /settings - Hiển thị và cấu hình settings"""
        keyboard = [
            [InlineKeyboardButton("📊 Cặp coin theo dõi", callback_data="settings_pairs")],
            [InlineKeyboardButton("⚖️ Quản lý rủi ro", callback_data="settings_risk")],
            [InlineKeyboardButton("🔔 Thông báo", callback_data="settings_alerts")],
            [InlineKeyboardButton("🧠 Machine Learning", callback_data="settings_ml")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "⚙️ **Cài đặt Bot**\n\nChọn mục cần cấu hình:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    async def performance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /performance - Hiển thị hiệu suất giao dịch"""
        try:
            conn = sqlite3.connect(self.signal_generator.db_manager.db_path)
            cursor = conn.cursor()
            
            # Tổng quan hiệu suất
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_trades,
                    SUM(CASE WHEN pnl_percent > 0 THEN 1 ELSE 0 END) as winning_trades,
                    AVG(pnl_percent) as avg_return,
                    SUM(pnl_percent) as total_return,
                    MAX(pnl_percent) as best_trade,
                    MIN(pnl_percent) as worst_trade
                FROM performance
                WHERE exit_time > ?
            ''', (int((datetime.now() - timedelta(days=30)).timestamp() * 1000),))
            
            stats = cursor.fetchone()
            
            if stats[0] == 0:
                await update.message.reply_text("Chưa có dữ liệu giao dịch trong 30 ngày qua.")
                return
            
            total_trades, winning_trades, avg_return, total_return, best_trade, worst_trade = stats
            win_rate = (winning_trades / total_trades) * 100
            
            # Hiệu suất theo symbol
            cursor.execute('''
                SELECT symbol, COUNT(*) as trades, AVG(pnl_percent) as avg_return
                FROM performance
                WHERE exit_time > ?
                GROUP BY symbol
                ORDER BY avg_return DESC
                LIMIT 5
            ''', (int((datetime.now() - timedelta(days=30)).timestamp() * 1000),))
            
            symbol_stats = cursor.fetchall()
            conn.close()
            
            perf_text = f"📈 **Hiệu suất 30 ngày**\n\n"
            perf_text += f"💼 Tổng giao dịch: {total_trades}\n"
            perf_text += f"✅ Giao dịch thắng: {winning_trades}\n"
            perf_text += f"📊 Tỷ lệ thắng: {win_rate:.1f}%\n"
            perf_text += f"💰 Lợi nhuận TB: {avg_return:.2f}%\n"
            perf_text += f"🎯 Tổng lợi nhuận: {total_return:.2f}%\n"
            perf_text += f"🚀 Giao dịch tốt nhất: {best_trade:.2f}%\n"
            perf_text += f"📉 Giao dịch tệ nhất: {worst_trade:.2f}%\n\n"
            
            perf_text += "**Top symbols:**\n"
            for symbol, trades, avg_ret in symbol_stats:
                perf_text += f"• {symbol}: {avg_ret:.2f}% ({trades} trades)\n"
            
            await update.message.reply_text(perf_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"Lỗi lấy dữ liệu hiệu suất: {str(e)}")
    
    async def portfolio_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Command /portfolio - Hiển thị thông tin danh mục"""
        try:
            # Get optimal weights
            symbols = config.DEFAULT_PAIRS
            optimal_weights = self.portfolio_optimizer.calculate_optimal_weights(symbols)
            
            portfolio_text = "📊 **Phân bổ danh mục tối ưu**\n\n"
            
            for symbol, weight in optimal_weights.items():
                portfolio_text += f"• {symbol}: {weight*100:.1f}%\n"
            
            portfolio_text += f"\n💡 Dựa trên Modern Portfolio Theory"
            portfolio_text += f"\n📈 Tối ưu hóa risk-adjusted return"
            
            await update.message.reply_text(portfolio_text, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"Lỗi tính toán danh mục: {str(e)}")
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Xử lý callback từ inline buttons"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "settings_pairs":
            text = "📊 **Cặp coin theo dõi**\n\n"
            text += "Sử dụng lệnh: /setpair BTC/USDT,ETH/USDT\n"
            text += "để thiết lập các cặp coin muốn theo dõi."
            
        elif query.data == "settings_risk":
            text = "⚖️ **Quản lý rủi ro**\n\n"
            text += f"• Rủi ro mỗi lệnh: {config.DEFAULT_RISK_PERCENT}%\n"
            text += "• Trailing stop loss: Tự động\n"
            text += "• Position sizing: Dựa trên ATR\n"
            text += "• Max positions: 5 cùng lúc"
            
        elif query.data == "settings_alerts":
            text = "🔔 **Cài đặt thông báo**\n\n"
            text += "• Tín hiệu mới: Bật\n"
            text += "• Cập nhật P&L: Bật\n"
            text += "• Cảnh báo rủi ro: Bật\n"
            text += "• Báo cáo hàng ngày: Bật"
            
        elif query.data == "settings_ml":
            text = "🧠 **Machine Learning**\n\n"
            text += "• Thuật toán: Random Forest\n"
            text += "• Tái huấn luyện: 24h\n"
            text += "• Lookback period: 30 ngày\n"
            text += "• Feature selection: Tự động"
        
        else:
            text = "Tính năng đang phát triển..."
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def send_signal_alert(self, signal: TradingSignal, user_ids: List[int]):
        """Gửi cảnh báo tín hiệu cho users"""
        try:
            signal_emoji = "🟢" if signal.signal_type == "BUY" else "🔴"
            confidence_emoji = "🔥" if signal.confidence > 0.7 else "⚡" if signal.confidence > 0.5 else "💫"
            
            alert_text = f"{signal_emoji} **Tín hiệu mới - {signal.symbol}**\n\n"
            alert_text += f"📊 **{signal.signal_type}** {confidence_emoji}\n"
            alert_text += f"🎯 Entry: ${signal.entry_price:.4f}\n"
            alert_text += f"🛑 Stop Loss: ${signal.stop_loss:.4f}\n"
            alert_text += f"💰 Take Profit: ${signal.take_profit:.4f}\n"
            alert_text += f"📈 Confidence: {signal.confidence*100:.1f}%\n"
            alert_text += f"🧠 ML Score: {signal.ml_score:.2f}\n"
            alert_text += f"😊 Sentiment: {signal.sentiment_score:.2f}\n"
            alert_text += f"💡 Reason: {signal.reason}\n"
            alert_text += f"⏰ {signal.timestamp.strftime('%H:%M:%S')}"
            
            # Risk calculation
            risk_reward = abs(signal.take_profit - signal.entry_price) / abs(signal.entry_price - signal.stop_loss)
            alert_text += f"\n📊 R:R = 1:{risk_reward:.2f}"
            
            for user_id in user_ids:
                try:
                    await self.application.bot.send_message(
                        chat_id=user_id,
                        text=alert_text,
                        parse_mode='Markdown'
                    )
                except Exception as e:
                    logger.error(f"Error sending alert to user {user_id}: {e}")
                    
        except Exception as e:
            logger.error(f"Error sending signal alert: {e}")
    
    def run(self):
        """Chạy Telegram bot"""
        logger.info("Starting Telegram bot...")
        self.application.run_polling()

# =============================================================================
# MAIN TRADING ENGINE
# =============================================================================

class TradingEngine:
    """Engine chính điều phối toàn bộ hệ thống"""
    
    def __init__(self):
        self.db_manager = DatabaseManager()
        self.data_collector = DataCollector(self.db_manager)
        self.tech_analyzer = TechnicalAnalyzer(self.db_manager)
        self.ml_engine = MLEngine(self.db_manager)
        self.signal_generator = SignalGenerator(
            self.db_manager, self.data_collector, 
            self.tech_analyzer, self.ml_engine
        )
        self.risk_manager = RiskManager(self.db_manager)
        self.portfolio_optimizer = PortfolioOptimizer(self.db_manager)
        self.telegram_bot = TelegramBot(
            self.signal_generator, self.risk_manager, self.portfolio_optimizer
        )
        
        self.active_positions = {}
        self.is_running = False
        self.user_ids = []  # Danh sách user IDs nhận thông báo
    
    async def initialize(self):
        """Khởi tạo hệ thống"""
        try:
            logger.info("Initializing Trading Engine...")
            
            # Huấn luyện ML models ban đầu
            await self.train_initial_models()
            
            # Khởi tạo data collection
            await self.initial_data_collection()
            
            logger.info("Trading Engine initialized successfully!")
            
        except Exception as e:
            logger.error(f"Error initializing Trading Engine: {e}")
    
    async def train_initial_models(self):
        """Huấn luyện ML models ban đầu"""
        logger.info("Training initial ML models...")
        
        for symbol in config.DEFAULT_PAIRS:
            try:
                # Collect training data
                await self.data_collector.collect_price_data(symbol, '1h', limit=500)
                df = self.db_manager.get_price_data(symbol, '1h', limit=500)
                
                if not df.empty:
                    df = self.tech_analyzer.calculate_indicators(df)
                    accuracy = self.ml_engine.train_model(symbol, df)
                    
                    if accuracy > 0.5:
                        logger.info(f"ML model for {symbol} trained with accuracy: {accuracy:.3f}")
                    else:
                        logger.warning(f"Low accuracy for {symbol}: {accuracy:.3f}")
                        
            except Exception as e:
                logger.error(f"Error training model for {symbol}: {e}")
    
    async def initial_data_collection(self):
        """Thu thập dữ liệu ban đầu"""
        logger.info("Collecting initial data...")
        
        for symbol in config.DEFAULT_PAIRS:
            for timeframe in ['5m', '15m', '1h', '4h', '1d']:
                try:
                    await self.data_collector.collect_price_data(symbol, timeframe, limit=100)
                except Exception as e:
                    logger.error(f"Error collecting data for {symbol} {timeframe}: {e}")
    
    async def market_analysis_loop(self):
        """Vòng lặp phân tích thị trường"""
        while self.is_running:
            try:
                logger.info("Running market analysis...")
                
                # Phân tích từng cặp coin
                for symbol in config.DEFAULT_PAIRS:
                    try:
                        signal = await self.signal_generator.generate_signal(symbol)
                        
                        if signal and signal.confidence > 0.5:
                            # Kiểm tra risk limits
                            active_positions_list = list(self.active_positions.values())
                            
                            if self.risk_manager.check_risk_limits(signal, active_positions_list):
                                # Gửi tín hiệu
                                await self.telegram_bot.send_signal_alert(signal, self.user_ids)
                                logger.info(f"Signal sent for {symbol}: {signal.signal_type}")
                                
                                # Lưu vào active positions (simulation)
                                self.active_positions[symbol] = {
                                    'symbol': symbol,
                                    'signal_type': signal.signal_type,
                                    'entry_price': signal.entry_price,
                                    'stop_loss': signal.stop_loss,
                                    'take_profit': signal.take_profit,
                                    'timestamp': signal.timestamp
                                }
                        
                    except Exception as e:
                        logger.error(f"Error analyzing {symbol}: {e}")
                
                # Cập nhật trailing stops
                await self.update_trailing_stops()
                
                # Nghỉ 5 phút trước khi phân tích tiếp
                await asyncio.sleep(300)
                
            except Exception as e:
                logger.error(f"Error in market analysis loop: {e}")
                await asyncio.sleep(60)
    
    async def update_trailing_stops(self):
        """Cập nhật trailing stop loss cho các positions"""
        try:
            for symbol, position in self.active_positions.items():
                # Lấy giá hiện tại
                current_price = await self.get_current_price(symbol)
                
                if current_price:
                    new_stop = self.risk_manager.update_trailing_stop(position, current_price)
                    
                    if new_stop != position['stop_loss']:
                        position['stop_loss'] = new_stop
                        logger.info(f"Updated trailing stop for {symbol}: {new_stop}")
                        
                        # Gửi thông báo cập nhật
                        update_text = f"📊 **Trailing Stop Updated**\n"
                        update_text += f"Symbol: {symbol}\n"
                        update_text += f"New Stop Loss: ${new_stop:.4f}\n"
                        update_text += f"Current Price: ${current_price:.4f}"
                        
                        for user_id in self.user_ids:
                            try:
                                await self.telegram_bot.application.bot.send_message(
                                    chat_id=user_id,
                                    text=update_text,
                                    parse_mode='Markdown'
                                )
                            except:
                                pass
                
        except Exception as e:
            logger.error(f"Error updating trailing stops: {e}")
    
    async def get_current_price(self, symbol: str) -> Optional[float]:
        """Lấy giá hiện tại của symbol"""
        try:
            exchange = self.data_collector.exchanges['binance']
            ticker = exchange.fetch_ticker(symbol)
            return ticker['last']
        except Exception as e:
            logger.error(f"Error getting current price for {symbol}: {e}")
            return None
    
    async def portfolio_rebalance_loop(self):
        """Vòng lặp rebalance danh mục"""
        while self.is_running:
            try:
                logger.info("Running portfolio rebalance...")
                
                # Tính toán trọng số tối ưu
                optimal_weights = self.portfolio_optimizer.calculate_optimal_weights(
                    config.DEFAULT_PAIRS
                )
                
                # Gửi thông báo rebalance recommendation
                rebalance_text = "📊 **Portfolio Rebalance Recommendation**\n\n"
                for symbol, weight in optimal_weights.items():
                    rebalance_text += f"• {symbol}: {weight*100:.1f}%\n"
                
                for user_id in self.user_ids:
                    try:
                        await self.telegram_bot.application.bot.send_message(
                            chat_id=user_id,
                            text=rebalance_text,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                
                # Nghỉ 8 tiếng trước khi rebalance tiếp
                await asyncio.sleep(config.PORTFOLIO_REBALANCE_HOURS * 3600)
                
            except Exception as e:
                logger.error(f"Error in portfolio rebalance loop: {e}")
                await asyncio.sleep(3600)
    
    async def model_retrain_loop(self):
        """Vòng lặp huấn luyện lại ML models"""
        while self.is_running:
            try:
                logger.info("Retraining ML models...")
                
                for symbol in config.DEFAULT_PAIRS:
                    try:
                        # Lấy dữ liệu mới
                        await self.data_collector.collect_price_data(symbol, '1h', limit=500)
                        df = self.db_manager.get_price_data(symbol, '1h', limit=500)
                        
                        if not df.empty:
                            df = self.tech_analyzer.calculate_indicators(df)
                            accuracy = self.ml_engine.train_model(symbol, df)
                            logger.info(f"Retrained {symbol} model, accuracy: {accuracy:.3f}")
                            
                    except Exception as e:
                        logger.error(f"Error retraining model for {symbol}: {e}")
                
                # Nghỉ 24 tiếng trước khi huấn luyện lại
                await asyncio.sleep(config.ML_RETRAIN_HOURS * 3600)
                
            except Exception as e:
                logger.error(f"Error in model retrain loop: {e}")
                await asyncio.sleep(3600)
    
    async def daily_report_loop(self):
        """Vòng lặp báo cáo hàng ngày"""
        while self.is_running:
            try:
                # Chờ đến 9h sáng
                now = datetime.now()
                target_time = now.replace(hour=9, minute=0, second=0, microsecond=0)
                
                if now > target_time:
                    target_time += timedelta(days=1)
                
                wait_seconds = (target_time - now).total_seconds()
                await asyncio.sleep(wait_seconds)
                
                # Tạo báo cáo hàng ngày
                report = await self.generate_daily_report()
                
                for user_id in self.user_ids:
                    try:
                        await self.telegram_bot.application.bot.send_message(
                            chat_id=user_id,
                            text=report,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                
            except Exception as e:
                logger.error(f"Error in daily report loop: {e}")
                await asyncio.sleep(3600)
    
    async def generate_daily_report(self) -> str:
        """Tạo báo cáo hàng ngày"""
        try:
            conn = sqlite3.connect(self.db_manager.db_path)
            cursor = conn.cursor()
            
            # Thống kê 24h qua
            yesterday = int((datetime.now() - timedelta(days=1)).timestamp() * 1000)
            
            cursor.execute('''
                SELECT COUNT(*) as signals, 
                       AVG(confidence) as avg_confidence
                FROM signals
                WHERE timestamp > ?
            ''', (yesterday,))
            
            signal_stats = cursor.fetchone()
            
            cursor.execute('''
                SELECT COUNT(*) as trades,
                       SUM(CASE WHEN pnl_percent > 0 THEN 1 ELSE 0 END) as wins,
                       AVG(pnl_percent) as avg_pnl
                FROM performance
                WHERE exit_time > ?
            ''', (yesterday,))
            
            trade_stats = cursor.fetchone()
            conn.close()
            
            report = f"📊 **Báo cáo hàng ngày - {datetime.now().strftime('%d/%m/%Y')}**\n\n"
            report += f"🔔 Tín hiệu phát sinh: {signal_stats[0]}\n"
            report += f"📈 Confidence trung bình: {(signal_stats[1] or 0)*100:.1f}%\n"
            
            if trade_stats[0] > 0:
                win_rate = (trade_stats[1] / trade_stats[0]) * 100
                report += f"💼 Giao dịch: {trade_stats[0]}\n"
                report += f"✅ Tỷ lệ thắng: {win_rate:.1f}%\n"
                report += f"💰 P&L trung bình: {trade_stats[2]:.2f}%\n"
            else:
                report += f"💼 Chưa có giao dịch nào hoàn thành\n"
            
            # Market overview
            report += f"\n📊 **Thị trường hôm nay:**\n"
            for symbol in config.DEFAULT_PAIRS[:3]:
                try:
                    current_price = await self.get_current_price(symbol)
                    if current_price:
                        report += f"• {symbol}: ${current_price:.4f}\n"
                except:
                    pass
            
            report += f"\n🤖 Bot hoạt động ổn định!"
            
            return report
            
        except Exception as e:
            logger.error(f"Error generating daily report: {e}")
            return "❌ Lỗi tạo báo cáo hàng ngày"
    
    async def start(self):
        """Khởi động hệ thống"""
        self.is_running = True
        
        # Khởi tạo
        await self.initialize()
        
        # Chạy các task đồng thời
        tasks = [
            asyncio.create_task(self.market_analysis_loop()),
            asyncio.create_task(self.portfolio_rebalance_loop()),
            asyncio.create_task(self.model_retrain_loop()),
            asyncio.create_task(self.daily_report_loop())
        ]
        
        # Chạy Telegram bot trong thread riêng
        import threading
        bot_thread = threading.Thread(target=self.telegram_bot.run)
        bot_thread.daemon = True
        bot_thread.start()
        
        logger.info("🚀 Trading Engine started successfully!")
        
        # Chờ tất cả tasks
        await asyncio.gather(*tasks)
    
    def stop(self):
        """Dừng hệ thống"""
        self.is_running = False
        logger.info("Trading Engine stopped")

# =============================================================================
# SECURITY & UTILITIES
# =============================================================================

class SecurityManager:
    """Quản lý bảo mật"""
    
    @staticmethod
    def encrypt_api_key(api_key: str, password: str) -> str:
        """Mã hóa API key"""
        try:
            from cryptography.fernet import Fernet
            from cryptography.hazmat.primitives import hashes
            from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
            import base64
            
            # Tạo key từ password
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'crypto_bot_salt',
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
            
            # Mã hóa
            f = Fernet(key)
            encrypted_key = f.encrypt(api_key.encode())
            
            return encrypted_key.decode()
            
        except Exception as e:
            logger.error(f"Error encrypting API key: {e}")
            return api_key
    
    @staticmethod
    def decrypt_api_key(encrypted_key: str, password: str) -> str:
        """Giải mã API key"""
        try:
            from cryptography.fernet import Fernet
            from cryptography.hazmat.primitives import hashes
            from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
            import base64
            
            # Tạo key từ password
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'crypto_bot_salt',
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
            
            # Giải mã
            f = Fernet(key)
            decrypted_key = f.decrypt(encrypted_key.encode())
            
            return decrypted_key.decode()
            
        except Exception as e:
            logger.error(f"Error decrypting API key: {e}")
            return encrypted_key

class BacktestEngine:
    """Engine backtesting"""
    
    def __init__(self, db_manager: DatabaseManager, tech_analyzer: TechnicalAnalyzer, 
                 ml_engine: MLEngine):
        self.db_manager = db_manager
        self.tech_analyzer = tech_analyzer
        self.ml_engine = ml_engine
    
    def run_backtest(self, symbol: str, start_date: datetime, end_date: datetime, 
                    initial_balance: float = 10000) -> Dict:
        """Chạy backtest cho một symbol"""
        try:
            # Lấy dữ liệu lịch sử
            df = self.db_manager.get_price_data(symbol, '1h', limit=1000)
            
            if df.empty:
                return {'error': 'No historical data available'}
            
            # Lọc theo thời gian
            df = df[(df.index >= start_date) & (df.index <= end_date)]
            
            if len(df) < 100:
                return {'error': 'Insufficient data for backtest period'}
            
            # Tính toán indicators
            df = self.tech_analyzer.calculate_indicators(df)
            
            # Huấn luyện model với dữ liệu training
            split_point = int(len(df) * 0.7)
            train_df = df.iloc[:split_point]
            test_df = df.iloc[split_point:]
            
            self.ml_engine.train_model(symbol, train_df)
            
            # Chạy backtest trên test data
            results = self.simulate_trading(test_df, symbol, initial_balance)
            
            return results
            
        except Exception as e:
            logger.error(f"Error running backtest: {e}")
            return {'error': str(e)}
    
    def simulate_trading(self, df: pd.DataFrame, symbol: str, initial_balance: float) -> Dict:
        """Mô phỏng giao dịch"""
        try:
            balance = initial_balance
            positions = []
            trades = []
            
            for i in range(50, len(df)):  # Bắt đầu từ index 50 để có đủ dữ liệu
                current_data = df.iloc[:i+1]
                
                # Tạo signal (simplified)
                current = current_data.iloc[-1]
                prev = current_data.iloc[-2]
                
                # Simple MA crossover strategy
                if (current['MA_20'] > current['MA_50'] and 
                    prev['MA_20'] <= prev['MA_50'] and 
                    len(positions) == 0):
                    
                    # Buy signal
                    entry_price = current['close']
                    stop_loss = entry_price * 0.98  # 2% stop loss
                    take_profit = entry_price * 1.06  # 6% take profit
                    
                    position = {
                        'type': 'long',
                        'entry_price': entry_price,
                        'entry_time': current_data.index[-1],
                        'stop_loss': stop_loss,
                        'take_profit': take_profit,
                        'size': balance * 0.1 / entry_price  # 10% of balance
                    }
                    positions.append(position)
                
                # Check exit conditions
                if positions:
                    position = positions[0]
                    current_price = current['close']
                    
                    exit_triggered = False
                    exit_reason = ""
                    
                    if current_price <= position['stop_loss']:
                        exit_triggered = True
                        exit_reason = "Stop Loss"
                    elif current_price >= position['take_profit']:
                        exit_triggered = True
                        exit_reason = "Take Profit"
                    
                    if exit_triggered:
                        # Calculate P&L
                        pnl = (current_price - position['entry_price']) * position['size']
                        pnl_percent = (current_price - position['entry_price']) / position['entry_price']
                        
                        balance += pnl
                        
                        trade = {
                            'entry_time': position['entry_time'],
                            'exit_time': current_data.index[-1],
                            'entry_price': position['entry_price'],
                            'exit_price': current_price,
                            'pnl': pnl,
                            'pnl_percent': pnl_percent,
                            'exit_reason': exit_reason
                        }
                        trades.append(trade)
                        positions.clear()
            
            # Calculate results
            if not trades:
                return {'error': 'No trades executed during backtest period'}
            
            total_return = (balance - initial_balance) / initial_balance
            winning_trades = [t for t in trades if t['pnl'] > 0]
            losing_trades = [t for t in trades if t['pnl'] <= 0]
            
            win_rate = len(winning_trades) / len(trades) if trades else 0
            avg_win = np.mean([t['pnl_percent'] for t in winning_trades]) if winning_trades else 0
            avg_loss = np.mean([t['pnl_percent'] for t in losing_trades]) if losing_trades else 0
            
            results = {
                'initial_balance': initial_balance,
                'final_balance': balance,
                'total_return': total_return,
                'total_trades': len(trades),
                'winning_trades': len(winning_trades),
                'losing_trades': len(losing_trades),
                'win_rate': win_rate,
                'avg_win': avg_win,
                'avg_loss': avg_loss,
                'profit_factor': abs(avg_win / avg_loss) if avg_loss != 0 else 0,
                'trades': trades
            }
            
            return results
            
        except Exception as e:
            logger.error(f"Error in trading simulation: {e}")
            return {'error': str(e)}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    """Hàm main để chạy bot"""
    print("🚀 Advanced Crypto Trading Bot")
    print("=" * 50)
    
    # Kiểm tra cấu hình
    if config.TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("❌ Lỗi: Chưa cấu hình TELEGRAM_BOT_TOKEN")
        print("Vui lòng cập nhật config trong file bot")
        return
    
    if config.BINANCE_API_KEY == "YOUR_BINANCE_API_KEY":
        print("❌ Lỗi: Chưa cấu hình BINANCE_API_KEY")
        print("Vui lòng cập nhật config trong file bot")
        return
    
    # Tạo và chạy trading engine
    engine = TradingEngine()
    
    try:
        # Chạy engine
        asyncio.run(engine.start())
        
    except KeyboardInterrupt:
        print("\n🛑 Đang dừng bot...")
        engine.stop()
        print("✅ Bot đã dừng an toàn")
        
    except Exception as e:
        logger.error(f"Critical error: {e}")
        print(f"❌ Lỗi nghiêm trọng: {e}")

if __name__ == "__main__":
    main()

# =============================================================================
# INSTALLATION & SETUP GUIDE
# =============================================================================

"""
📋 HƯỚNG DẪN CÀI ĐẶT VÀ THIẾT LẬP BOT

1. CÀI ĐẶT THƯ VIỆN:
   pip install ccxt pandas numpy scikit-learn ta tweepy python-telegram-bot
   pip install plotly sqlite3 cryptography asyncio

2. THIẾT LẬP API KEYS:
   - Tạo bot Telegram qua @BotFather
   - Lấy API key từ Binance (hoặc sàn khác)
   - Đăng ký Twitter API (tùy chọn)
   - Cập nhật config trong file bot

3. CHẠY BOT:
   python crypto_trading_bot.py

4. SỬ DỤNG:
   - Gửi /start cho bot trên Telegram
   - Thiết lập các cặp coin theo dõi
   - Nhận tín hiệu giao dịch tự động

5. TÍNH NĂNG NÂNG CAO:
   - Machine Learning tự học
   - Quản lý rủi ro thông minh
   - Tối ưu hóa danh mục
   - Phân tích sentiment từ Twitter
   - Backtesting chiến lược

6. BẢO MẬT:
   - Không chia sẻ API keys
   - Sử dụng VPS để chạy 24/7
   - Bật 2FA cho tài khoản sàn
   - Backup dữ liệu thường xuyên

7. KHUYẾN CÁO:
   - Bot chỉ cung cấp tín hiệu, không tự động giao dịch
   - Luôn kiểm tra và xác nhận trước khi vào lệnh
   - Quản lý rủi ro cẩn thận
   - Không đầu tư quá 5% tổng tài sản vào crypto

🚀 Chúc bạn giao dịch thành công!
"""
